# 13. ì‹¤ì œ í”„ë¡œì íŠ¸ ì˜ˆì œ

## 13.1 ì±„íŒ… ì„œë²„/í´ë¼ì´ì–¸íŠ¸ êµ¬í˜„

**C ì–¸ì–´ ê¸°ë°˜ TCP ì†Œì¼“ í”„ë¡œê·¸ë˜ë°**ì˜ ëŒ€í‘œì ì¸ ì˜ˆì œ ì¤‘ í•˜ë‚˜ëŠ” **ë‹¤ì¤‘ í´ë¼ì´ì–¸íŠ¸ ì±„íŒ… ì„œë²„**ë‹¤.
 ì´ ì˜ˆì œë¥¼ í†µí•´ ë‹¤ìŒì„ ì‹¤ì „ êµ¬í˜„í•˜ë©° í•™ìŠµí•  ìˆ˜ ìˆë‹¤:

- `socket()`, `bind()`, `listen()`, `accept()` í•¨ìˆ˜ì˜ ì—°ë™
- í´ë¼ì´ì–¸íŠ¸ ë™ì‹œ ì ‘ì† ì²˜ë¦¬ (`select`, `pthread`, `fork` ë°©ì‹ ê°€ëŠ¥)
- ë©”ì‹œì§€ ë¸Œë¡œë“œìºìŠ¤íŠ¸ ë¡œì§
- ì—°ê²° ì¢…ë£Œ ë° ì—ëŸ¬ ì²˜ë¦¬

------

### âœ… 1. ê¸°ë³¸ êµ¬ì¡° ìš”ì•½

```
[Client 1]---\         /---[Client N]
              \       /
           [ Chat Server ]
```

ì„œë²„ëŠ” ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì˜ ì†Œì¼“ì„ ê´€ë¦¬í•˜ë©°,
 â†’ í•˜ë‚˜ì˜ í´ë¼ì´ì–¸íŠ¸ë¡œë¶€í„° ìˆ˜ì‹ ëœ ë©”ì‹œì§€ë¥¼
 â†’ **ì „ì²´ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ë¸Œë¡œë“œìºìŠ¤íŠ¸**í•œë‹¤.

------

### âœ… 2. ìš”êµ¬ì‚¬í•­ ì •ë¦¬

- í´ë¼ì´ì–¸íŠ¸ëŠ” ì„œë²„ì— ì ‘ì† í›„ ë©”ì‹œì§€ë¥¼ ì…ë ¥í•´ ì „ì†¡
- ì„œë²„ëŠ” í•´ë‹¹ ë©”ì‹œì§€ë¥¼ ëª¨ë“  ë‹¤ë¥¸ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì „ì†¡
- `exit` ì…ë ¥ ì‹œ í´ë¼ì´ì–¸íŠ¸ ì¢…ë£Œ
- ì„œë²„ëŠ” í´ë¼ì´ì–¸íŠ¸ ì—°ê²° í•´ì œ ì‹œ ë¦¬ì†ŒìŠ¤ íšŒìˆ˜

------

### âœ… 3. êµ¬í˜„ ë°©ì‹

- ì†Œì¼“ì€ `TCP (SOCK_STREAM)` ì‚¬ìš©
- ë‹¤ì¤‘ ì ‘ì†ì€ `select()` í•¨ìˆ˜ ê¸°ë°˜ (ê°„ë‹¨í•˜ê³  ì§ê´€ì )

------

### âœ… 4. ì„œë²„ ì½”ë“œ (`chat_server.c`)

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/select.h>

#define PORT 12345
#define MAX_CLIENTS 10
#define BUF_SIZE 1024

int main() {
    int server_fd, client_fd, max_fd;
    int client_socks[MAX_CLIENTS] = {0};
    struct sockaddr_in serv_addr, cli_addr;
    socklen_t addr_len = sizeof(cli_addr);
    char buf[BUF_SIZE];

    fd_set read_fds;

    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd < 0) { perror("socket"); exit(1); }

    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY;
    serv_addr.sin_port = htons(PORT);

    bind(server_fd, (struct sockaddr*)&serv_addr, sizeof(serv_addr));
    listen(server_fd, 5);

    printf("Chat server started on port %d\n", PORT);

    while (1) {
        FD_ZERO(&read_fds);
        FD_SET(server_fd, &read_fds);
        max_fd = server_fd;

        for (int i = 0; i < MAX_CLIENTS; i++) {
            if (client_socks[i] > 0) {
                FD_SET(client_socks[i], &read_fds);
                if (client_socks[i] > max_fd)
                    max_fd = client_socks[i];
            }
        }

        select(max_fd + 1, &read_fds, NULL, NULL, NULL);

        // ìƒˆ ì—°ê²° ìˆ˜ë½
        if (FD_ISSET(server_fd, &read_fds)) {
            client_fd = accept(server_fd, (struct sockaddr*)&cli_addr, &addr_len);
            for (int i = 0; i < MAX_CLIENTS; i++) {
                if (client_socks[i] == 0) {
                    client_socks[i] = client_fd;
                    printf("Client connected: FD %d\n", client_fd);
                    break;
                }
            }
        }

        // í´ë¼ì´ì–¸íŠ¸ ë©”ì‹œì§€ ìˆ˜ì‹ 
        for (int i = 0; i < MAX_CLIENTS; i++) {
            int sd = client_socks[i];
            if (FD_ISSET(sd, &read_fds)) {
                int n = read(sd, buf, BUF_SIZE);
                if (n <= 0) {
                    close(sd);
                    client_socks[i] = 0;
                    printf("Client disconnected: FD %d\n", sd);
                } else {
                    buf[n] = '\0';
                    printf("Message from FD %d: %s", sd, buf);

                    // ë‹¤ë¥¸ ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ë¸Œë¡œë“œìºìŠ¤íŠ¸
                    for (int j = 0; j < MAX_CLIENTS; j++) {
                        if (client_socks[j] > 0 && client_socks[j] != sd)
                            send(client_socks[j], buf, n, 0);
                    }
                }
            }
        }
    }

    return 0;
}
```

------

### âœ… 5. í´ë¼ì´ì–¸íŠ¸ ì½”ë“œ (`chat_client.c`)

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <arpa/inet.h>

#define PORT 12345
#define BUF_SIZE 1024

int sockfd;

void* recv_handler(void* arg) {
    char buf[BUF_SIZE];
    int n;
    while ((n = read(sockfd, buf, BUF_SIZE)) > 0) {
        buf[n] = '\0';
        printf(">> %s", buf);
    }
    return NULL;
}

int main() {
    struct sockaddr_in serv_addr;
    char buf[BUF_SIZE];
    pthread_t recv_thread;

    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) { perror("socket"); exit(1); }

    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(PORT);
    serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");

    if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
        perror("connect"); exit(1);
    }

    pthread_create(&recv_thread, NULL, recv_handler, NULL);

    while (1) {
        fgets(buf, BUF_SIZE, stdin);
        if (strncmp(buf, "exit", 4) == 0)
            break;
        send(sockfd, buf, strlen(buf), 0);
    }

    close(sockfd);
    return 0;
}
```

------

### âœ… 6. ì‹¤í–‰ ë°©ë²•

1. ì„œë²„ ì‹¤í–‰:

```
gcc -o chat_server chat_server.c
./chat_server
```

2. í´ë¼ì´ì–¸íŠ¸ ì‹¤í–‰:

```
gcc -o chat_client chat_client.c -pthread
./chat_client
```

ğŸ’¡ ì—¬ëŸ¬ í„°ë¯¸ë„ì—ì„œ í´ë¼ì´ì–¸íŠ¸ë¥¼ ë™ì‹œì— ì‹¤í–‰í•˜ì—¬ ì„œë¡œ ì±„íŒ… ê°€ëŠ¥.

------

### âœ… í™•ì¥ ì•„ì´ë””ì–´

- ì‚¬ìš©ì ID ë³„ë„ ê´€ë¦¬ (ì˜ˆ: ë‹‰ë„¤ì„)
- ë©”ì‹œì§€ í˜•ì‹ ì§€ì • (JSON êµ¬ì¡° ë“±)
- ì±„íŒ…ë°© ê¸°ëŠ¥ (room ë¶„ë¦¬)
- ë©€í‹°ìŠ¤ë ˆë“œ ì„œë²„ ì „í™˜ (`pthread` ë°©ì‹)
- ë³´ì•ˆ ì¶”ê°€ (TLS/SSL)

## 13.2 ë©€í‹° í´ë¼ì´ì–¸íŠ¸ Echo ì„œë²„

### ğŸ“Œ ëª©ì 

ì—¬ëŸ¬ í´ë¼ì´ì–¸íŠ¸ê°€ ë™ì‹œì— ì ‘ì†í•´ ì„œë²„ì— ë©”ì‹œì§€ë¥¼ ë³´ë‚´ë©´, ì„œë²„ëŠ” **ê° í´ë¼ì´ì–¸íŠ¸ì—ê²Œ í•´ë‹¹ ë©”ì‹œì§€ë¥¼ ê·¸ëŒ€ë¡œ ëŒë ¤ì£¼ëŠ”** Echo ê¸°ëŠ¥ì„ ìˆ˜í–‰í•œë‹¤.
 **ë‹¤ì¤‘ ì ‘ì† ì²˜ë¦¬**ì™€ **í´ë¼ì´ì–¸íŠ¸ êµ¬ë¶„**ì„ ìœ„í•œ ì‹¤ìŠµìš© ì˜ˆì œë¡œ ì í•©í•˜ë©°, `select()` ê¸°ë°˜ I/O multiplexing êµ¬ì¡°ë¥¼ ì²´ë“í•˜ëŠ” ë° íš¨ê³¼ì ì´ë‹¤.

------

### âœ… 1. í•µì‹¬ ê¸°ìˆ  ìš”ì•½

- `socket()`, `bind()`, `listen()`, `accept()`
- `select()`ë¡œ ì†Œì¼“ ìƒíƒœ ëª¨ë‹ˆí„°ë§
- ì ‘ì†ëœ í´ë¼ì´ì–¸íŠ¸ ê°ê°ì—ê²Œ **ìì‹ ì´ ë³´ë‚¸ ë©”ì‹œì§€ë§Œ** Echo ì „ì†¡
- ì„œë²„ëŠ” ë‹¤ì¤‘ í´ë¼ì´ì–¸íŠ¸ì˜ ì ‘ì†/ì¢…ë£Œë¥¼ ê´€ë¦¬

------

### âœ… 2. êµ¬í˜„ êµ¬ì¡°

```
[Client 1] â†’ Hello â†’ [ Server ] â†’ Hello â†’ [Client 1]
[Client 2] â†’ Test  â†’ [ Server ] â†’ Test  â†’ [Client 2]
```

ë¸Œë¡œë“œìºìŠ¤íŠ¸ ì—†ì´, **ê°œë³„ í´ë¼ì´ì–¸íŠ¸ì™€ ì„œë²„ ê°„ì˜ 1:1 Echo ì²˜ë¦¬**

------

### âœ… 3. ì½”ë“œ: `echo_server.c`

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/select.h>

#define PORT 12345
#define MAX_CLIENTS 10
#define BUF_SIZE 1024

int main() {
    int server_fd, new_socket, max_sd, sd;
    int client_socket[MAX_CLIENTS] = {0};
    struct sockaddr_in address;
    socklen_t addrlen = sizeof(address);
    char buffer[BUF_SIZE];

    fd_set readfds;

    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd == 0) { perror("socket failed"); exit(EXIT_FAILURE); }

    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    bind(server_fd, (struct sockaddr*)&address, sizeof(address));
    listen(server_fd, 5);
    printf("Echo server listening on port %d\n", PORT);

    while (1) {
        FD_ZERO(&readfds);
        FD_SET(server_fd, &readfds);
        max_sd = server_fd;

        for (int i = 0; i < MAX_CLIENTS; i++) {
            sd = client_socket[i];
            if (sd > 0) FD_SET(sd, &readfds);
            if (sd > max_sd) max_sd = sd;
        }

        select(max_sd + 1, &readfds, NULL, NULL, NULL);

        // ìƒˆ í´ë¼ì´ì–¸íŠ¸ ì—°ê²°
        if (FD_ISSET(server_fd, &readfds)) {
            new_socket = accept(server_fd, (struct sockaddr*)&address, &addrlen);
            printf("New connection, socket fd is %d\n", new_socket);

            for (int i = 0; i < MAX_CLIENTS; i++) {
                if (client_socket[i] == 0) {
                    client_socket[i] = new_socket;
                    break;
                }
            }
        }

        // ê¸°ì¡´ í´ë¼ì´ì–¸íŠ¸ ë©”ì‹œì§€ ì²˜ë¦¬
        for (int i = 0; i < MAX_CLIENTS; i++) {
            sd = client_socket[i];
            if (FD_ISSET(sd, &readfds)) {
                int valread = read(sd, buffer, BUF_SIZE);
                if (valread <= 0) {
                    close(sd);
                    client_socket[i] = 0;
                    printf("Client disconnected: fd %d\n", sd);
                } else {
                    buffer[valread] = '\0';
                    send(sd, buffer, valread, 0); // Echo
                }
            }
        }
    }

    return 0;
}
```

------

### âœ… 4. í´ë¼ì´ì–¸íŠ¸: `echo_client.c`

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 12345
#define BUF_SIZE 1024

int main() {
    int sock;
    struct sockaddr_in serv_addr;
    char buffer[BUF_SIZE], recv_buf[BUF_SIZE];

    sock = socket(AF_INET, SOCK_STREAM, 0);
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(PORT);
    serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");

    connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));

    while (1) {
        printf("Message: ");
        fgets(buffer, BUF_SIZE, stdin);

        if (strncmp(buffer, "exit", 4) == 0)
            break;

        send(sock, buffer, strlen(buffer), 0);
        int n = read(sock, recv_buf, BUF_SIZE);
        recv_buf[n] = '\0';
        printf("Echo: %s", recv_buf);
    }

    close(sock);
    return 0;
}
```

------

### âœ… 5. ì‹¤í–‰ ì˜ˆ

#### ì„œë²„ ì‹¤í–‰

```
gcc -o echo_server echo_server.c
./echo_server
```

#### í´ë¼ì´ì–¸íŠ¸ ì‹¤í–‰

```
gcc -o echo_client echo_client.c
./echo_client
```

ğŸ’¡ ì—¬ëŸ¬ í„°ë¯¸ë„ì—ì„œ í´ë¼ì´ì–¸íŠ¸ ì‹¤í–‰ ê°€ëŠ¥. ê°ìì˜ ì…ë ¥ì— ëŒ€í•´ ìê¸°ë§Œ ì‘ë‹µë°›ìŒ.

------

### âœ… í™•ì¥ í¬ì¸íŠ¸

- `select()` â†’ `epoll()`ìœ¼ë¡œ í™•ì¥ (ì„±ëŠ¥ í–¥ìƒ)
- `pthread` ë˜ëŠ” `fork`ë¡œ í´ë¼ì´ì–¸íŠ¸ ì²˜ë¦¬ ë³‘ë ¬í™”
- Echo ì™¸ì—ë„ ëª…ë ¹ì–´ ê¸°ë°˜ ì…ë ¥/ì‘ë‹µ êµ¬ì¡° ë„ì…
- ë©”ì‹œì§€ ë¡œê·¸ ì €ì¥ ë° ê¸°ë¡ ê¸°ëŠ¥ ì¶”ê°€
- TCP Keep-Alive ì„¤ì • (`SO_KEEPALIVE`)

## 13.3 íŒŒì¼ ì—…ë¡œë“œ/ë‹¤ìš´ë¡œë“œ ì„œë²„

**íŒŒì¼ ì „ì†¡ ê¸°ëŠ¥**ì€ ë„¤íŠ¸ì›Œí¬ í”„ë¡œê·¸ë˜ë°ì—ì„œ ë§¤ìš° ì¤‘ìš”í•œ ì‘ìš© ë¶„ì•¼ë‹¤.
 ì´ í•­ëª©ì—ì„œëŠ” **TCP ê¸°ë°˜ìœ¼ë¡œ íŒŒì¼ì„ ì—…ë¡œë“œí•˜ê±°ë‚˜ ë‹¤ìš´ë¡œë“œí•˜ëŠ” ì„œë²„/í´ë¼ì´ì–¸íŠ¸ êµ¬ì¡°**ë¥¼ ì§ì ‘ êµ¬í˜„í•˜ë©°, ì‹¤ì „ì—ì„œ ì‚¬ìš©í•˜ëŠ”:

- íŒŒì¼ ì…ì¶œë ¥(`fopen`, `fread`, `fwrite`)
- ì „ì†¡ í”„ë¡œí† ì½œ ì„¤ê³„ (ê°„ë‹¨í•œ ëª…ë ¹ì–´ ê¸°ë°˜)
- ë²„í¼ í¬ê¸° ì„¤ì •, ì „ì†¡ ì™„ë£Œ ì²˜ë¦¬

ë“±ì„ ëª¨ë‘ ë‹¤ë£¬ë‹¤.

------

### âœ… 1. ì „ì²´ ì„¤ê³„ ê°œìš”

```
[Client] --- upload/download ëª…ë ¹ì–´ --> [Server]

upload:  client â†’ server ì „ì†¡ â†’ ì„œë²„ íŒŒì¼ ì €ì¥
download: server â†’ client ì „ì†¡ â†’ í´ë¼ì´ì–¸íŠ¸ ì €ì¥
```

------

### âœ… 2. ëª…ë ¹ì–´ í”„ë¡œí† ì½œ ì„¤ê³„ (ê°„ë‹¨í•œ êµ¬ì¡°)

í´ë¼ì´ì–¸íŠ¸ê°€ ë¬¸ìì—´ì„ ë¨¼ì € ì „ì†¡:

- `UPLOAD filename\n` : ì„œë²„ì—ê²Œ ì—…ë¡œë“œ ìš”ì²­
- `DOWNLOAD filename\n` : ì„œë²„ì—ê²Œ ë‹¤ìš´ë¡œë“œ ìš”ì²­

ê·¸ ë‹¤ìŒ ì„œë²„ê°€ OK ì‘ë‹µ í›„ ì „ì†¡ì´ ì‹œì‘ëœë‹¤.

------

### âœ… 3. ì„œë²„ ì½”ë“œ (`file_server.c`)

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 12345
#define BUF_SIZE 1024

void handle_client(int client_fd) {
    char command[BUF_SIZE], filename[BUF_SIZE];
    FILE* fp;
    int bytes;
    char buffer[BUF_SIZE];

    // ëª…ë ¹ì–´ ìˆ˜ì‹ 
    bytes = read(client_fd, command, sizeof(command) - 1);
    command[bytes] = '\0';
    sscanf(command, "%s %s", buffer, filename);

    if (strcmp(buffer, "UPLOAD") == 0) {
        fp = fopen(filename, "wb");
        if (!fp) {
            perror("fopen");
            return;
        }
        write(client_fd, "OK", 2);
        while ((bytes = read(client_fd, buffer, BUF_SIZE)) > 0)
            fwrite(buffer, 1, bytes, fp);
        fclose(fp);
        printf("Uploaded file: %s\n", filename);

    } else if (strcmp(buffer, "DOWNLOAD") == 0) {
        fp = fopen(filename, "rb");
        if (!fp) {
            write(client_fd, "NOFILE", 6);
            return;
        }
        write(client_fd, "OK", 2);
        while ((bytes = fread(buffer, 1, BUF_SIZE, fp)) > 0)
            write(client_fd, buffer, bytes);
        fclose(fp);
        printf("Sent file: %s\n", filename);
    }

    close(client_fd);
}

int main() {
    int server_fd, client_fd;
    struct sockaddr_in serv_addr, cli_addr;
    socklen_t cli_len = sizeof(cli_addr);

    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY;
    serv_addr.sin_port = htons(PORT);

    bind(server_fd, (struct sockaddr*)&serv_addr, sizeof(serv_addr));
    listen(server_fd, 5);
    printf("File server listening on port %d\n", PORT);

    while (1) {
        client_fd = accept(server_fd, (struct sockaddr*)&cli_addr, &cli_len);
        if (fork() == 0) {
            close(server_fd);
            handle_client(client_fd);
            exit(0);
        }
        close(client_fd);
    }

    return 0;
}
```

------

### âœ… 4. í´ë¼ì´ì–¸íŠ¸ ì½”ë“œ (`file_client.c`)

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 12345
#define BUF_SIZE 1024

void upload_file(int sock, const char* filename) {
    char buffer[BUF_SIZE];
    FILE* fp = fopen(filename, "rb");
    if (!fp) { perror("fopen"); return; }

    sprintf(buffer, "UPLOAD %s\n", filename);
    send(sock, buffer, strlen(buffer), 0);

    read(sock, buffer, 2); // OK ì‘ë‹µ ëŒ€ê¸°

    int bytes;
    while ((bytes = fread(buffer, 1, BUF_SIZE, fp)) > 0)
        send(sock, buffer, bytes, 0);
    fclose(fp);
}

void download_file(int sock, const char* filename) {
    char buffer[BUF_SIZE];
    sprintf(buffer, "DOWNLOAD %s\n", filename);
    send(sock, buffer, strlen(buffer), 0);

    read(sock, buffer, 2); // OK or NOFILE
    if (strncmp(buffer, "OK", 2) != 0) {
        printf("File not found on server.\n");
        return;
    }

    FILE* fp = fopen(filename, "wb");
    int bytes;
    while ((bytes = read(sock, buffer, BUF_SIZE)) > 0)
        fwrite(buffer, 1, bytes, fp);
    fclose(fp);
}

int main() {
    int sock;
    struct sockaddr_in serv_addr;
    char cmd[BUF_SIZE], filename[BUF_SIZE];

    sock = socket(AF_INET, SOCK_STREAM, 0);
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(PORT);
    serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");

    connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));

    printf("Command (upload/download): ");
    scanf("%s %s", cmd, filename);

    if (strcmp(cmd, "upload") == 0) {
        upload_file(sock, filename);
    } else if (strcmp(cmd, "download") == 0) {
        download_file(sock, filename);
    }

    close(sock);
    return 0;
}
```

------

### âœ… 5. ì‹¤í–‰ ìˆœì„œ

#### ì„œë²„ ì‹¤í–‰

```
gcc -o file_server file_server.c
./file_server
```

#### í´ë¼ì´ì–¸íŠ¸ ì‹¤í–‰

```
gcc -o file_client file_client.c
./file_client
```

ì…ë ¥ ì˜ˆ:

```
upload data.txt
```

ë˜ëŠ”

```
download image.jpg
```

------

### âœ… í–¥í›„ í™•ì¥ ì•„ì´ë””ì–´

- íŒŒì¼ í¬ê¸° ë¨¼ì € ì „ì†¡í•˜ì—¬ ì •í™•í•œ ìˆ˜ì‹  ì¢…ë£Œ ì¡°ê±´ ì„¤ì •
- ì „ì†¡ ìƒíƒœ í‘œì‹œ (ì§„í–‰ë¥  %)
- ëŒ€ìš©ëŸ‰ íŒŒì¼ì„ ìœ„í•œ `sendfile()` í™œìš©
- íŒŒì¼ ì¶©ëŒ/ì¤‘ë³µ ì²˜ë¦¬ ë¡œì§ ì¶”ê°€
- TLS ì•”í˜¸í™”, ì¸ì¦ ê¸°ëŠ¥ ì¶”ê°€

## 13.4 RESTful API í”„ë¡ì‹œ ì„œë²„

### ğŸ¯ ëª©ì 

**RESTful API í”„ë¡ì‹œ ì„œë²„**ëŠ” í´ë¼ì´ì–¸íŠ¸ì˜ HTTP ìš”ì²­ì„ ë°›ì•„, **ë°±ì—”ë“œ ì„œë²„(API)**ë¡œ ìš”ì²­ì„ ì¤‘ê³„í•˜ê³  ì‘ë‹µì„ ë‹¤ì‹œ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì „ë‹¬í•œë‹¤.
 ì´ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ìƒí™©ì—ì„œ ìœ ìš©í•˜ë‹¤:

- ë³´ì•ˆ, ì¸ì¦ì„ í”„ë¡ì‹œì—ì„œ ì²˜ë¦¬
- ë¡œê¹… ë° í•„í„°ë§ ì ìš©
- íŠ¸ë˜í”½ ë¡œë“œë°¸ëŸ°ì‹±
- API ì—”ë“œí¬ì¸íŠ¸ ì¶”ìƒí™”

------

### âœ… 1. êµ¬ì¡° ê°œìš”

```
[Client] --> [C í”„ë¡ì‹œ ì„œë²„] --> [REST API ì„œë²„ (ex. httpbin.org)]
   â‡…               â‡…
REQ/RES          REQ/RES
```

- í”„ë¡ì‹œ ì„œë²„ëŠ” HTTP ìš”ì²­ì„ íŒŒì‹±í•˜ê³ , ë°±ì—”ë“œì— ë™ì¼ ìš”ì²­ì„ ë³´ë‚´ê³ , ì‘ë‹µì„ ë°›ì•„ ë‹¤ì‹œ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì „ë‹¬í•¨

------

### âœ… 2. ìš”êµ¬ì‚¬í•­ ì •ë¦¬

- HTTP `GET`, `POST` ìš”ì²­ì„ ë°›ì•„ ë‹¤ë¥¸ ì„œë²„ë¡œ ì¤‘ê³„
- í´ë¼ì´ì–¸íŠ¸ ìš”ì²­ í—¤ë”ì™€ ë°”ë””ë¥¼ ê·¸ëŒ€ë¡œ ì „ë‹¬
- ì„œë²„ ì‘ë‹µ í—¤ë”ì™€ ë°”ë””ë¥¼ ë‹¤ì‹œ í´ë¼ì´ì–¸íŠ¸ì— ë°˜í™˜
- `select()` ë˜ëŠ” ë‹¨ì¼ ìŠ¤ë ˆë“œ ê¸°ë°˜ìœ¼ë¡œ êµ¬í˜„

------

### âœ… 3. ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„ íƒ

- **libcurl**: REST API í˜¸ì¶œì— ì‚¬ìš© (`curl_easy_perform`)
- **ê¸°ë³¸ C ì†Œì¼“**: í´ë¼ì´ì–¸íŠ¸ ìš”ì²­ ìˆ˜ì‹ 

ì„¤ì¹˜:

```
sudo apt install libcurl4-openssl-dev
```

------

### âœ… 4. ì½”ë“œ êµ¬í˜„ (`proxy_server.c`)

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <curl/curl.h>

#define PORT 8080
#define BUF_SIZE 4096

struct MemoryStruct {
    char* memory;
    size_t size;
};

size_t write_callback(void* contents, size_t size, size_t nmemb, void* userp) {
    size_t realsize = size * nmemb;
    struct MemoryStruct* mem = (struct MemoryStruct*) userp;

    mem->memory = realloc(mem->memory, mem->size + realsize + 1);
    memcpy(&(mem->memory[mem->size]), contents, realsize);
    mem->size += realsize;
    mem->memory[mem->size] = 0;

    return realsize;
}

void handle_http_proxy(int client_sock) {
    char buffer[BUF_SIZE];
    int len = read(client_sock, buffer, BUF_SIZE - 1);
    buffer[len] = '\0';

    printf("Client request:\n%s\n", buffer);

    // libcurlë¡œ ë°±ì—”ë“œ REST API ìš”ì²­ ì „ì†¡
    CURL* curl = curl_easy_init();
    if (curl) {
        struct MemoryStruct chunk = { malloc(1), 0 };

        curl_easy_setopt(curl, CURLOPT_URL, "https://httpbin.org/get");
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&chunk);

        CURLcode res = curl_easy_perform(curl);
        if (res != CURLE_OK) {
            char* err = (char*) curl_easy_strerror(res);
            write(client_sock, err, strlen(err));
        } else {
            char response[BUF_SIZE];
            snprintf(response, sizeof(response),
                "HTTP/1.1 200 OK\r\nContent-Length: %ld\r\nContent-Type: application/json\r\n\r\n%s",
                chunk.size, chunk.memory);
            write(client_sock, response, strlen(response));
        }

        free(chunk.memory);
        curl_easy_cleanup(curl);
    }

    close(client_sock);
}
```

------

### âœ… 5. ë©”ì¸ ì„œë²„ ë£¨í”„

```
int main() {
    int server_fd, client_fd;
    struct sockaddr_in addr;
    socklen_t addrlen = sizeof(addr);

    curl_global_init(CURL_GLOBAL_ALL);
    server_fd = socket(AF_INET, SOCK_STREAM, 0);

    addr.sin_family = AF_INET;
    addr.sin_port = htons(PORT);
    addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_fd, (struct sockaddr*)&addr, sizeof(addr));
    listen(server_fd, 5);

    printf("Proxy server running on port %d\n", PORT);

    while (1) {
        client_fd = accept(server_fd, (struct sockaddr*)&addr, &addrlen);
        if (fork() == 0) {
            close(server_fd);
            handle_http_proxy(client_fd);
            exit(0);
        }
        close(client_fd);
    }

    curl_global_cleanup();
    return 0;
}
```

------

### âœ… 6. ì‹¤í–‰ ë°©ë²•

#### ë¹Œë“œ

```
gcc -o proxy_server proxy_server.c -lcurl
```

#### ì‹¤í–‰

```
./proxy_server
```

#### í…ŒìŠ¤íŠ¸ (ë‹¤ë¥¸ í„°ë¯¸ë„ì—ì„œ)

```
curl http://localhost:8080
```

ì‘ë‹µ:

```
{
  "args": {}, 
  "headers": {
    ...
  },
  "url": "https://httpbin.org/get"
}
```

------

### âœ… í™•ì¥ ì•„ì´ë””ì–´

- HTTP `POST`, `PUT`, `DELETE` ì§€ì›
- í”„ë¡ì‹œ ìš”ì²­ ë¡œê·¸ ë‚¨ê¸°ê¸°
- ì¸ì¦ í—¤ë” ì¶”ê°€ (Bearer, API key)
- TLS ì¸ì¦ì„œ ê²€ì¦ ì˜µì…˜ ì¡°ì •
- ë©€í‹° í´ë¼ì´ì–¸íŠ¸ ì§€ì› (`select`, `pthread`)

## 13.5 ë¶€í•˜ í…ŒìŠ¤íŠ¸ìš© ë„¤íŠ¸ì›Œí¬ íŠ¸ë˜í”½ ìƒì„±ê¸°

### ğŸ¯ ëª©ì 

**ë¶€í•˜ í…ŒìŠ¤íŠ¸(load testing)**ëŠ” ë„¤íŠ¸ì›Œí¬ ì„œë²„ë‚˜ ì‹œìŠ¤í…œì´ ì–¼ë§ˆë‚˜ ë§ì€ ìš”ì²­ì„ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ”ì§€ë¥¼ í‰ê°€í•˜ëŠ” ë° í•„ìˆ˜ì ì¸ ì ˆì°¨ë‹¤.
 ì´ í•­ëª©ì—ì„œëŠ” **C ì–¸ì–´ë¡œ ë‹¤ìˆ˜ì˜ í´ë¼ì´ì–¸íŠ¸ ìš”ì²­ì„ ë¹ ë¥´ê²Œ ìƒì„±í•´ ë„¤íŠ¸ì›Œí¬ íŠ¸ë˜í”½ì„ ì˜ë„ì ìœ¼ë¡œ ë°œìƒì‹œí‚¤ëŠ” í…ŒìŠ¤íŠ¸ ë„êµ¬**ë¥¼ ì‘ì„±í•œë‹¤.

------

### âœ… 1. ì£¼ìš” ê¸°ëŠ¥ ìš”ì•½

- TCP ì—°ê²°ì„ ìˆ˜ë°± ê°œ ì´ìƒ ìƒì„± (ë©€í‹°ìŠ¤ë ˆë”© ë˜ëŠ” ë£¨í”„ ê¸°ë°˜)
- ì¼ì • ì£¼ê¸°ë¡œ ìš”ì²­ ì „ì†¡
- ì„œë²„ì˜ ì‘ë‹µ ì—¬ë¶€ì™€ ì²˜ë¦¬ ì‹œê°„ ì¸¡ì •
- ì´ˆë‹¹ ìš”ì²­ ìˆ˜(RPS) ë° ì‘ë‹µ ì†ë„ ì¸¡ì • ê°€ëŠ¥

------

### âœ… 2. íŠ¸ë˜í”½ ìƒì„±ê¸° êµ¬ì¡°

```
[Load Generator]
 â”œâ”€ Thread 1 â†’ connect + send â†’ recv â†’ close
 â”œâ”€ Thread 2 â†’ connect + send â†’ recv â†’ close
 â””â”€ ... Ã— N

â†“ ìˆ˜ì²œ ê°œ ìš”ì²­ ìƒì„± í›„ ì‘ë‹µ ì‹œê°„, ì‹¤íŒ¨ìœ¨ ì¸¡ì • ê°€ëŠ¥
```

------

### âœ… 3. ê°„ë‹¨í•œ íŠ¸ë˜í”½ ìƒì„±ê¸° ì˜ˆì œ (`loadgen.c`)

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <arpa/inet.h>
#include <sys/time.h>

#define THREAD_COUNT 100
#define REQ_PER_THREAD 50
#define SERVER_IP "127.0.0.1"
#define SERVER_PORT 12345
#define MESSAGE "ping\n"

void* thread_func(void* arg) {
    for (int i = 0; i < REQ_PER_THREAD; i++) {
        int sock = socket(AF_INET, SOCK_STREAM, 0);
        if (sock < 0) continue;

        struct sockaddr_in serv_addr = {
            .sin_family = AF_INET,
            .sin_port = htons(SERVER_PORT)
        };
        inet_pton(AF_INET, SERVER_IP, &serv_addr.sin_addr);

        if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            close(sock);
            continue;
        }

        send(sock, MESSAGE, strlen(MESSAGE), 0);

        char buf[1024];
        int n = read(sock, buf, sizeof(buf) - 1);
        if (n > 0) {
            buf[n] = '\0';
            printf("[Thread %ld] Response: %s", (long)arg, buf);
        }

        close(sock);
        usleep(50000); // 50ms delay between requests
    }
    return NULL;
}

int main() {
    pthread_t threads[THREAD_COUNT];
    struct timeval start, end;
    gettimeofday(&start, NULL);

    for (long i = 0; i < THREAD_COUNT; i++)
        pthread_create(&threads[i], NULL, thread_func, (void*)i);

    for (int i = 0; i < THREAD_COUNT; i++)
        pthread_join(threads[i], NULL);

    gettimeofday(&end, NULL);
    double elapsed = (end.tv_sec - start.tv_sec) + (end.tv_usec - start.tv_usec) / 1e6;
    printf("\nTotal time: %.3f sec\n", elapsed);
    printf("Total requests: %d\n", THREAD_COUNT * REQ_PER_THREAD);
    printf("Requests per second: %.2f RPS\n", (THREAD_COUNT * REQ_PER_THREAD) / elapsed);
    return 0;
}
```

------

### âœ… 4. ì‹¤í–‰ ë°©ë²•

#### ì„œë²„ ì¤€ë¹„

ë¨¼ì €, `echo_server` í˜¹ì€ í…ŒìŠ¤íŠ¸ ëŒ€ìƒ TCP ì„œë²„ë¥¼ 12345 í¬íŠ¸ì—ì„œ ì‹¤í–‰ ì¤‘ì´ì–´ì•¼ í•¨

#### ë¹Œë“œ ë° ì‹¤í–‰

```
gcc -o loadgen loadgen.c -pthread
./loadgen
```

------

### âœ… 5. ì¶œë ¥ ì˜ˆì‹œ

```
[Thread 0] Response: pong
[Thread 1] Response: pong
...
Total time: 3.258 sec
Total requests: 5000
Requests per second: 1534.77 RPS
```

------

### âœ… 6. í™•ì¥ ì•„ì´ë””ì–´

- ìš”ì²­ ë©”ì‹œì§€ë¥¼ íŒŒì¼ ë˜ëŠ” ì¸ìë¡œë¶€í„° ë™ì ìœ¼ë¡œ ì„¤ì •
- ì‹¤íŒ¨ìœ¨, í‰ê·  RTT ì¸¡ì •
- ì‘ë‹µ ë¡œê·¸ íŒŒì¼ ì €ì¥
- `epoll` ê¸°ë°˜ìœ¼ë¡œ íŠ¸ë˜í”½ ì¦ê°€
- UDP íŠ¸ë˜í”½ë„ ì§€ì› ê°€ëŠ¥í•˜ê²Œ ìˆ˜ì •
- JSON ê¸°ë°˜ ìš”ì²­ + HTTP API ë¶€í•˜ í…ŒìŠ¤íŠ¸ë¡œ ì „í™˜ ê°€ëŠ¥