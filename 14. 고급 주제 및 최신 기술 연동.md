# 14. ê³ ê¸‰ ì£¼ì œ ë° ìµœì‹  ê¸°ìˆ  ì—°ë™

## 14.1 ë¹„ë™ê¸° ë„¤íŠ¸ì›Œí¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ (libevent, libuv) ì‚¬ìš©ë²•

### ğŸ¯ í•™ìŠµ ëª©í‘œ

- `select`, `poll`, `epoll` ë“±ì˜ ì €ìˆ˜ì¤€ ì‹œìŠ¤í…œì½œ ì—†ì´
   **ê³ ì„±ëŠ¥ ë„¤íŠ¸ì›Œí¬ I/O ë¹„ë™ê¸° ì²˜ë¦¬**ë¥¼ êµ¬í˜„í•˜ê³ ì í•  ë•Œ,
   C ê¸°ë°˜ìœ¼ë¡œ ë„ë¦¬ ì‚¬ìš©í•˜ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ 2ê°€ì§€ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.

| ë¼ì´ë¸ŒëŸ¬ë¦¬ | íŠ¹ì§•                                                         |
| ---------- | ------------------------------------------------------------ |
| `libevent` | `epoll`, `kqueue` ë“±ì„ ìë™ ê°ì§€í•˜ì—¬ **ì´ë²¤íŠ¸ ê¸°ë°˜ ë¹„ë™ê¸° ì²˜ë¦¬** ì œê³µ |
| `libuv`    | Node.jsì˜ ëŸ°íƒ€ì„ ê¸°ë°˜ì´ë©° **í¬ë¡œìŠ¤í”Œë«í¼ ì§€ì›**, íƒ€ì´ë¨¸/íŒŒì¼/IPC ì§€ì› |

------

### âœ… 1. libevent ê¸°ë³¸ ì‚¬ìš©ë²•

#### ğŸ”¹ ì„¤ì¹˜

```
sudo apt install libevent-dev
```

#### ğŸ”¹ ì£¼ìš” API êµ¬ì¡°

```
struct event_base* base = event_base_new();        // ì´ë²¤íŠ¸ ë£¨í”„
struct event* ev = event_new(base, fd, flags, callback, arg);  
event_add(ev, timeout);                             // ì´ë²¤íŠ¸ ë“±ë¡
event_base_dispatch(base);                          // ë£¨í”„ ì‹œì‘
```

------

#### âœ… TCP Echo ì„œë²„ ì˜ˆì œ (libevent)

```
#include <event2/event.h>
#include <event2/bufferevent.h>
#include <event2/listener.h>
#include <netinet/in.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#define PORT 12345

void echo_read_cb(struct bufferevent* bev, void* ctx) {
    char buffer[1024];
    int n = bufferevent_read(bev, buffer, sizeof(buffer));
    bufferevent_write(bev, buffer, n); // Echo back
}

void echo_event_cb(struct bufferevent* bev, short events, void* ctx) {
    if (events & BEV_EVENT_EOF || events & BEV_EVENT_ERROR)
        bufferevent_free(bev);
}

void accept_conn_cb(struct evconnlistener* listener, evutil_socket_t fd,
                    struct sockaddr* addr, int socklen, void* ctx) {
    struct event_base* base = ctx;
    struct bufferevent* bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);
    bufferevent_setcb(bev, echo_read_cb, NULL, echo_event_cb, NULL);
    bufferevent_enable(bev, EV_READ | EV_WRITE);
}

int main() {
    struct event_base* base;
    struct evconnlistener* listener;
    struct sockaddr_in sin;

    base = event_base_new();

    memset(&sin, 0, sizeof(sin));
    sin.sin_family = AF_INET;
    sin.sin_port = htons(PORT);

    listener = evconnlistener_new_bind(base, accept_conn_cb, base,
        LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE, -1,
        (struct sockaddr*)&sin, sizeof(sin));

    printf("libevent echo server running on port %d\n", PORT);
    event_base_dispatch(base);
    return 0;
}
```

#### ğŸ”¹ ì»´íŒŒì¼

```
gcc -o echo_libevent echo_libevent.c -levent
```

------

### âœ… 2. libuv ê¸°ë³¸ ì‚¬ìš©ë²•

#### ğŸ”¹ ì„¤ì¹˜

```
sudo apt install libuv1-dev
```

#### ğŸ”¹ í•µì‹¬ êµ¬ì¡°

```
uv_loop_t* loop = uv_default_loop();  // ì´ë²¤íŠ¸ ë£¨í”„
uv_tcp_t server;                      // TCP ì„œë²„ ê°ì²´
uv_tcp_init(loop, &server);
uv_listen((uv_stream_t*)&server, backlog, on_new_connection);
uv_run(loop, UV_RUN_DEFAULT);
```

------

#### âœ… TCP Echo ì„œë²„ ì˜ˆì œ (libuv)

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <uv.h>

#define PORT 12345

uv_loop_t* loop;

void alloc_buffer(uv_handle_t* handle, size_t suggested_size, uv_buf_t* buf) {
    buf->base = malloc(suggested_size);
    buf->len = suggested_size;
}

void echo_write(uv_write_t* req, int status) {
    free(req->data);
    free(req);
}

void echo_read(uv_stream_t* client, ssize_t nread, const uv_buf_t* buf) {
    if (nread > 0) {
        uv_write_t* req = malloc(sizeof(uv_write_t));
        uv_buf_t wrbuf = uv_buf_init(buf->base, nread);
        req->data = buf->base;
        uv_write(req, client, &wrbuf, 1, echo_write);
        return;
    }
    if (nread < 0) uv_close((uv_handle_t*)client, NULL);
    free(buf->base);
}

void on_new_connection(uv_stream_t* server, int status) {
    uv_tcp_t* client = malloc(sizeof(uv_tcp_t));
    uv_tcp_init(loop, client);
    uv_accept(server, (uv_stream_t*)client);
    uv_read_start((uv_stream_t*)client, alloc_buffer, echo_read);
}

int main() {
    loop = uv_default_loop();
    uv_tcp_t server;
    uv_tcp_init(loop, &server);

    struct sockaddr_in addr;
    uv_ip4_addr("0.0.0.0", PORT, &addr);
    uv_tcp_bind(&server, (const struct sockaddr*)&addr, 0);

    uv_listen((uv_stream_t*)&server, 128, on_new_connection);
    printf("libuv echo server running on port %d\n", PORT);
    uv_run(loop, UV_RUN_DEFAULT);
    return 0;
}
```

#### ğŸ”¹ ì»´íŒŒì¼

```
gcc -o echo_libuv echo_libuv.c -luv
```

------

### âœ… 3. libevent vs libuv ë¹„êµ

| í•­ëª©         | libevent                        | libuv                              |
| ------------ | ------------------------------- | ---------------------------------- |
| ëŒ€ìƒ         | ì£¼ë¡œ ë„¤íŠ¸ì›Œí¬ ì„œë²„              | ë„¤íŠ¸ì›Œí¬ + íƒ€ì´ë¨¸/íŒŒì¼/IPC ë“± ë²”ìš© |
| ì¶”ìƒí™” ìˆ˜ì¤€  | ì¤‘ê°„ ìˆ˜ì¤€ (buffer, listener)    | ë” ë†’ì€ ìˆ˜ì¤€ (í•¸ë“¤ ë‹¨ìœ„ ì¶”ìƒí™”)    |
| ì„±ëŠ¥         | ê³ ì„±ëŠ¥ (`epoll`, `kqueue` ê¸°ë°˜) | ê³ ì„±ëŠ¥ + ë” ë§ì€ ê¸°ëŠ¥ í¬í•¨         |
| ì½”ë“œ ë‚œì´ë„  | ë¹„êµì  ì§ê´€ì                    | ì½œë°± ì²´ì¸ ë§ì•„ ì•½ê°„ ë³µì¡           |
| Node.js ê¸°ë°˜ | âŒ                               | âœ…                                  |

------

### âœ… 4. ì‹¤ì „ í™œìš© íŒ

- `select`/`epoll`ë¡œ ì§ì ‘ êµ¬í˜„í•  ì‹œê°„ê³¼ ë¹„ìš©ì„ ì•„ë¼ê³  ì‹¶ë‹¤ë©´ ì ê·¹ ì¶”ì²œ
- ì„œë²„ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸, ê²Œì„ ì„œë²„, ì´ë²¤íŠ¸ ì¤‘ì‹¬ API ì„œë²„ì—ì„œ ë§ì´ ì‚¬ìš©ë¨
- ë©€í‹° í”Œë«í¼ êµ¬í˜„ ì‹œ `libuv` ì¶”ì²œ
- ë‹¨ìˆœ TCP ì´ë²¤íŠ¸ í•¸ë“¤ë§ì´ë©´ `libevent`ê°€ ë” ê°„ë‹¨

## 14.2 Cì™€ MQTT ì—°ë™ (mosquitto)

### ğŸ¯ í•™ìŠµ ëª©í‘œ

MQTT(Message Queuing Telemetry Transport)ëŠ” **ê²½ëŸ‰ ë©”ì‹œì§€ ë¸Œë¡œì»¤ í”„ë¡œí† ì½œ**ë¡œ,
 IoT, ì„¼ì„œ, ì‹¤ì‹œê°„ ì œì–´ ë“± **ë¦¬ì†ŒìŠ¤ê°€ ì œí•œëœ í™˜ê²½**ì—ì„œ ì´ìƒì ì¸ ë©”ì‹œì§• ì‹œìŠ¤í…œì´ë‹¤.

ì´ ì ˆì—ì„œëŠ” **mosquitto C ë¼ì´ë¸ŒëŸ¬ë¦¬**ë¥¼ ì´ìš©í•´ MQTT í´ë¼ì´ì–¸íŠ¸ë¥¼ êµ¬í˜„í•˜ëŠ” ë°©ë²•ì„ í•™ìŠµí•œë‹¤.

------

### âœ… 1. ê¸°ë³¸ ê°œë… ì •ë¦¬

| í•­ëª©            | ì„¤ëª…                                                   |
| --------------- | ------------------------------------------------------ |
| **Broker**      | ë©”ì‹œì§€ë¥¼ ì¤‘ê³„í•˜ëŠ” ì„œë²„ (ì˜ˆ: Mosquitto)                 |
| **Publisher**   | íŠ¹ì • **topic**ì— ë©”ì‹œì§€ë¥¼ ì „ì†¡í•˜ëŠ” í´ë¼ì´ì–¸íŠ¸          |
| **Subscriber**  | íŠ¹ì • **topic**ì„ êµ¬ë…í•˜ê³  ë©”ì‹œì§€ë¥¼ ìˆ˜ì‹ í•˜ëŠ” í´ë¼ì´ì–¸íŠ¸ |
| **Topic**       | ë©”ì‹œì§€ë¥¼ ë¶„ë¥˜í•˜ëŠ” ê²½ë¡œ (ì˜ˆ: `/sensor/temp`)            |
| **QoS (0/1/2)** | ì „ì†¡ ë³´ì¥ ìˆ˜ì¤€ (ìµœëŒ€ 1íšŒ, ìµœì†Œ 1íšŒ, ì •í™•íˆ 1íšŒ)        |

------

### âœ… 2. ê°œë°œ í™˜ê²½ êµ¬ì„±

#### ğŸ”¹ Mosquitto ë¸Œë¡œì»¤ ì„¤ì¹˜

```
sudo apt install mosquitto mosquitto-clients
sudo systemctl start mosquitto
```

#### ğŸ”¹ C ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„¤ì¹˜

```
sudo apt install libmosquitto-dev
```

------

### âœ… 3. C Publisher ì˜ˆì œ (`mqtt_pub.c`)

```
#include <mosquitto.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main() {
    mosquitto_lib_init();

    struct mosquitto* mosq = mosquitto_new("pub-client", true, NULL);
    if (!mosq) {
        perror("mosquitto_new");
        return 1;
    }

    mosquitto_connect(mosq, "localhost", 1883, 60);

    for (int i = 0; i < 5; i++) {
        char payload[64];
        sprintf(payload, "Hello MQTT %d", i);
        mosquitto_publish(mosq, NULL, "test/topic", strlen(payload), payload, 0, false);
        printf("Published: %s\n", payload);
        sleep(1);
    }

    mosquitto_disconnect(mosq);
    mosquitto_destroy(mosq);
    mosquitto_lib_cleanup();

    return 0;
}
```

------

### âœ… 4. C Subscriber ì˜ˆì œ (`mqtt_sub.c`)

```
#include <mosquitto.h>
#include <stdio.h>
#include <stdlib.h>

void on_message(struct mosquitto* mosq, void* userdata,
                const struct mosquitto_message* message) {
    printf("Received on %s: %s\n", message->topic, (char*)message->payload);
}

int main() {
    mosquitto_lib_init();

    struct mosquitto* mosq = mosquitto_new("sub-client", true, NULL);
    if (!mosq) {
        perror("mosquitto_new");
        return 1;
    }

    mosquitto_message_callback_set(mosq, on_message);

    mosquitto_connect(mosq, "localhost", 1883, 60);
    mosquitto_subscribe(mosq, NULL, "test/topic", 0);

    mosquitto_loop_start(mosq);
    printf("Subscribed to 'test/topic'\n");
    getchar();  // ì—”í„° ì¹˜ë©´ ì¢…ë£Œ
    mosquitto_loop_stop(mosq, true);

    mosquitto_disconnect(mosq);
    mosquitto_destroy(mosq);
    mosquitto_lib_cleanup();

    return 0;
}
```

------

### âœ… 5. ì»´íŒŒì¼ ë° ì‹¤í–‰

```
gcc -o mqtt_pub mqtt_pub.c -lmosquitto
gcc -o mqtt_sub mqtt_sub.c -lmosquitto
```

#### ì‹¤í–‰ ìˆœì„œ

```
./mqtt_sub       # ìˆ˜ì‹  ëŒ€ê¸°
./mqtt_pub       # ë©”ì‹œì§€ ì „ì†¡
```

------

### âœ… 6. í…ŒìŠ¤íŠ¸ í™•ì¸

```
# Mosquitto CLIë¡œë„ í™•ì¸ ê°€ëŠ¥
mosquitto_sub -t test/topic
mosquitto_pub -t test/topic -m "From terminal"
```

------

### âœ… 7. í™•ì¥ í¬ì¸íŠ¸

- QoS ìˆ˜ì¤€ ì¡°ì • (`mosquitto_publish`ì˜ qos íŒŒë¼ë¯¸í„°)
- ì¸ì¦ ì„¤ì • (`mosquitto_username_pw_set`)
- TLS ë³´ì•ˆ ì ìš©
- ì—¬ëŸ¬ í† í”½ ë™ì‹œ êµ¬ë… (`mosquitto_subscribe_multiple`)
- `mosquitto_loop_forever()` â†’ `mosquitto_loop_start()`ë¡œ ë¹„ë™ê¸°í™” ê°€ëŠ¥

## 14.3 ë©€í‹°ì½”ì–´ ë„¤íŠ¸ì›Œí¬ ì²˜ë¦¬ ëª¨ë¸

### ğŸ¯ í•™ìŠµ ëª©í‘œ

í˜„ëŒ€ì˜ ë©€í‹°ì½”ì–´ CPU í™˜ê²½ì—ì„œ **ë‹¨ì¼ ìŠ¤ë ˆë“œ ê¸°ë°˜ ë„¤íŠ¸ì›Œí¬ ì„œë²„**ëŠ” ì„±ëŠ¥ í•œê³„ì— ë„ë‹¬í•œë‹¤.
 ì´ ë‹¨ì›ì—ì„œëŠ” **ì—¬ëŸ¬ ì½”ì–´ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ í™œìš©í•˜ëŠ” ë„¤íŠ¸ì›Œí¬ ì²˜ë¦¬ ëª¨ë¸ë“¤**ì„ ë¹„êµí•˜ê³ ,
 C ì–¸ì–´ë¡œ êµ¬í˜„ ê°€ëŠ¥í•œ êµ¬ì¡° ì„¤ê³„ê¹Œì§€ ì„¤ëª…í•œë‹¤.

------

### âœ… 1. ì™œ ë©€í‹°ì½”ì–´ ëª¨ë¸ì´ í•„ìš”í•œê°€?

- **ë‹¨ì¼ ìŠ¤ë ˆë“œ ì²˜ë¦¬ ë°©ì‹**ì€ ë³‘ëª© ë°œìƒ (`select`, `epoll`ë§Œ ì‚¬ìš©í•˜ëŠ” ê²½ìš°)
- ì„œë²„ ë¶€í•˜ ì¦ê°€ ì‹œ **CPU 1ê°œë§Œ 100%**, ë‚˜ë¨¸ì§€ëŠ” Idle
- ë©€í‹° ì½”ì–´ í™œìš©ì´ ê°€ëŠ¥í•œ êµ¬ì¡°ë¡œ ë³€ê²½í•˜ë©´ **ì„±ëŠ¥ì´ ì„ í˜• ì¦ê°€**

------

### âœ… 2. ëŒ€í‘œì ì¸ ë©€í‹°ì½”ì–´ ì²˜ë¦¬ ëª¨ë¸

| ëª¨ë¸                         | ì„¤ëª…                                        | ì¥ì                  | ë‹¨ì                   |
| ---------------------------- | ------------------------------------------- | -------------------- | --------------------- |
| **`fork` ëª¨ë¸**              | ì½”ì–´ ìˆ˜ë§Œí¼ í”„ë¡œì„¸ìŠ¤ ìƒì„±                   | ì»¤ë„ ìŠ¤ì¼€ì¤„ë§ ìµœì í™” | ë©”ëª¨ë¦¬ ë³µì‚¬ ë¹„ìš©      |
| **`pthread` ëª¨ë¸**           | ìŠ¤ë ˆë“œ í’€ì—ì„œ ì²˜ë¦¬ ë¶„ì‚°                     | ìì› ê³µìœ  ìš©ì´       | ë™ê¸°í™” ë³µì¡           |
| **`prefork` ëª¨ë¸**           | í”„ë¡œì„¸ìŠ¤ ë¯¸ë¦¬ ìƒì„± í›„ socket ê³µìœ            | ì•ˆì •ì  + ë¹ ë¥¸ ì‘ë‹µ   | socket race ë°©ì§€ í•„ìš” |
| **SO_REUSEPORT**             | ì»¤ë„ ë ˆë²¨ì—ì„œ socketì„ ë¶„ì‚° ìˆ˜ì‹             | ì½”ë“œ ë³µì¡ë„ ë‚®ìŒ     | ì»¤ë„ 3.9+ ì´ìƒ        |
| **Event-loop + Thread pool** | ì´ë²¤íŠ¸ ìˆ˜ì‹ ì€ ë©”ì¸ìŠ¤ë ˆë“œ, ì²˜ë¦¬ëŠ” ì›Œì»¤ìŠ¤ë ˆë“œ | êµ¬ì¡°ì  í™•ì¥ì„± ìš°ìˆ˜   | ì„¤ê³„ ë³µì¡ë„ â†‘         |

------

### âœ… 3. í•µì‹¬ ê¸°ë²•: `SO_REUSEPORT`

#### ğŸ”¹ ì„¤ëª…

- ì—¬ëŸ¬ í”„ë¡œì„¸ìŠ¤/ìŠ¤ë ˆë“œê°€ **ê°™ì€ í¬íŠ¸ë¥¼ listen()** í•˜ë„ë¡ í—ˆìš©
- ì»¤ë„ì´ ìë™ìœ¼ë¡œ **connectionì„ ë¶„ì‚° ì²˜ë¦¬**

#### ğŸ”¹ ì½”ë“œ ì˜ˆì‹œ (ë‹¤ì¤‘ í”„ë¡œì„¸ìŠ¤ ìˆ˜ì‹ )

```
int sock = socket(AF_INET, SOCK_STREAM, 0);
int opt = 1;
setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
setsockopt(sock, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt));
```

#### ğŸ”¹ í”„ë¡œì„¸ìŠ¤ ì˜ˆì‹œ

```
for (int i = 0; i < num_cores; i++) {
    if (fork() == 0) {
        listen_and_accept(); // ê° í”„ë¡œì„¸ìŠ¤ê°€ ë™ì¼ í¬íŠ¸ listen
        exit(0);
    }
}
```

------

### âœ… 4. êµ¬ì¡°ë„ ì˜ˆì‹œ: Event-loop + Thread Pool

```
        +--------------------+
        |    Main Thread     |
        |  epoll/select loop |
        +--------+-----------+
                 |
                 v
        +--------+--------+
        |   Task Queue    |
        +--------+--------+
                 |
     +-----------+-----------+
     |           |           |
Worker 1     Worker 2     Worker N
 (thread)     (thread)     (thread)
```

------

### âœ… 5. C ê¸°ë°˜ ì—ì½” ì„œë²„ ë©€í‹°ì½”ì–´ í™•ì¥ ì˜ˆì‹œ

#### `fork + SO_REUSEPORT` ê¸°ë°˜

```
int cores = sysconf(_SC_NPROCESSORS_ONLN);
for (int i = 0; i < cores; i++) {
    if (fork() == 0) {
        run_server();  // ë™ì¼ í¬íŠ¸ listen + epoll
        exit(0);
    }
}
```

â†’ ê° í”„ë¡œì„¸ìŠ¤ëŠ” ì»¤ë„ì— ì˜í•´ ìë™ ë¶„ì‚° ì²˜ë¦¬ë¨ (ë¶€í•˜ê· í˜•)

------

### âœ… 6. ì›Œì»¤ ìŠ¤ë ˆë“œ ê¸°ë°˜ ë¹„ë™ê¸° ì²˜ë¦¬ ì˜ˆì‹œ íë¦„

- `epoll_wait()` â†’ ì´ë²¤íŠ¸ ë°œìƒ
- ì—°ê²°ëœ ì†Œì¼“ fdë¥¼ ì›Œì»¤ ìŠ¤ë ˆë“œ í’€ì˜ íë¡œ ì „ë‹¬
- ê° ìŠ¤ë ˆë“œëŠ” fdë¥¼ ì½ê³ , ì²˜ë¦¬ í›„ ì‘ë‹µ

```
// ë©”ì¸ ìŠ¤ë ˆë“œ
while (1) {
    events = epoll_wait(...);
    for (...) {
        enqueue(fd); // ì›Œì»¤ì— ì „ë‹¬
    }
}

// ì›Œì»¤ ìŠ¤ë ˆë“œ
void* worker(void*) {
    while (1) {
        int fd = dequeue();
        read(fd, buf, ...);
        write(fd, buf, ...);
    }
}
```

------

### âœ… 7. ê³ ì„±ëŠ¥ ë©€í‹°ì½”ì–´ ì„œë²„ êµ¬í˜„ íŒ

- `CPU Core` ìˆ˜ì— ë§ëŠ” ì›Œì»¤ ìˆ˜ ì¡°ì •
- `SO_REUSEPORT` vs `accept mutex` ì„ íƒ ì „ëµ
- NUMA í™˜ê²½ì—ì„  CPU ë°”ì¸ë”© ê³ ë ¤ (`sched_setaffinity`)
- ë¶€í•˜ ì¸¡ì • ë„êµ¬ ë³‘í–‰ (`htop`, `perf`, `strace`)

------

### âœ… 8. ì‹¤ì „ ì ìš© ì˜ˆ

| í”„ë ˆì„ì›Œí¬ / ì„œë²„   | ë©€í‹°ì½”ì–´ ë°©ì‹                       |
| ------------------- | ----------------------------------- |
| **nginx**           | `prefork + SO_REUSEPORT`            |
| **Node.js Cluster** | `fork()` + IPC                      |
| **libevent**        | ì“°ë ˆë“œí’€ or í”„ë¡œì„¸ìŠ¤ fork ë³‘í–‰ ê°€ëŠ¥ |
| **libuv**           | ìì²´ ì›Œì»¤ ìŠ¤ë ˆë“œ + ì´ë²¤íŠ¸ë£¨í”„       |

## 14.4 ì»¤ë„ ìš°íšŒ ë„¤íŠ¸ì›Œí‚¹ (DPDK, XDP ê°œìš”)

### ğŸ¯ í•™ìŠµ ëª©í‘œ

ë¦¬ëˆ…ìŠ¤ ì»¤ë„ ë„¤íŠ¸ì›Œí¬ ìŠ¤íƒì„ **ìš°íšŒ(bypass)**í•˜ê±°ë‚˜ **ìµœì í™”**í•˜ëŠ” ê¸°ìˆ ì€ ì´ˆê³ ì† íŠ¸ë˜í”½ ì²˜ë¦¬, íŒ¨í‚· í•„í„°ë§, ë„¤íŠ¸ì›Œí¬ ê¸°ëŠ¥ ê°€ìƒí™”(NFV) ë“±ì—ì„œ í•„ìˆ˜ì ì´ë‹¤.
 ì´ ì ˆì—ì„œëŠ” ëŒ€í‘œì ì¸ ì»¤ë„ ìš°íšŒ ê¸°ìˆ ì¸ **DPDK**ì™€ **XDP/eBPF**ì— ëŒ€í•´ ê°œë…ê³¼ êµ¬ì¡°, ì‹¤ì œ ì ìš© ë°©í–¥ì„ ì´í•´í•˜ëŠ” ë° ì´ˆì ì„ ë‘”ë‹¤.

------

### âœ… 1. ì™œ ì»¤ë„ ìš°íšŒê°€ í•„ìš”í•œê°€?

#### ê¸°ì¡´ ì»¤ë„ ë„¤íŠ¸ì›Œí¬ ìŠ¤íƒ ë¬¸ì œì :

- ë³µì¡í•œ ê³„ì¸µ êµ¬ì¡° (L2 â†’ L3 â†’ L4)
- ë§ì€ context switch, copy overhead
- user spaceì—ì„œ íŒ¨í‚· ìˆ˜ì‹ /ì „ì†¡ ì‹œ ì§€ì—° ì¦ê°€

#### í•„ìš”ì„±:

- ì´ˆë‹¹ **ìˆ˜ë°±ë§Œ íŒ¨í‚· ì²˜ë¦¬ (Mpps)**
- ì§€ì—° ìˆ˜ Î¼s ì´í•˜ë¡œ ë‹¨ì¶•
- NIC â†’ Application ì§ì ‘ ì—°ê²°í•˜ëŠ” êµ¬ì¡°

------

### âœ… 2. DPDK (Data Plane Development Kit)

#### ğŸ”¹ ê°œìš”

- **Intel**ì´ ì£¼ë„ ê°œë°œí•œ **user-space ê³ ì† íŒ¨í‚· ì²˜ë¦¬ í”„ë ˆì„ì›Œí¬**
- **polling ê¸°ë°˜**, **zero-copy**, **NUMA-aware**

#### ğŸ”¹ íŠ¹ì§•

| í•­ëª©           | ì„¤ëª…                                       |
| -------------- | ------------------------------------------ |
| Polling ë°©ì‹   | NICìœ¼ë¡œë¶€í„° ì¸í„°ëŸ½íŠ¸ ì—†ì´ ë°˜ë³µ ìˆ˜ì‹         |
| Zero-copy      | NIC â†’ ë©”ëª¨ë¦¬ â†’ Appë¡œ ì§ì ‘ ì „ë‹¬ (ì»¤ë„ ìš°íšŒ) |
| HugePages ì‚¬ìš© | ëŒ€ìš©ëŸ‰ í˜ì´ì§€ë¥¼ í†µí•œ TLB miss ìµœì†Œí™”       |
| ë‹¤ì¤‘ ì½”ì–´ ì²˜ë¦¬ | ë©€í‹°í, ë©€í‹°ìŠ¤ë ˆë“œ ê¸°ë°˜ ë³‘ë ¬ ìˆ˜ì‹  ì²˜ë¦¬     |

#### ğŸ”¹ êµ¬ì¡°

```
[NIC] â†’ [DPDK Poller] â†’ [User App]
       â†˜ï¸ HugePages / DMA
```

#### ğŸ”¹ ì„¤ì¹˜ ê°œë…

```
sudo apt install dpdk dpdk-dev
```

â†’ ì‹¤ì œ ì‚¬ìš©ì€ ë°”ì¸ë”©ëœ NICì—ì„œë§Œ ê°€ëŠ¥ (`vfio-pci`, `uio_pci_generic` ë“± ì‚¬ìš©)

------

#### âœ… DPDK ì½”ë“œ ì˜ˆì‹œ ìŠ¤ì¼€ì¹˜

```
rte_eth_rx_burst(port_id, queue_id, &mbuf, 32);  // íŒ¨í‚· ìˆ˜ì‹ 
rte_pktmbuf_mtod(mbuf, void*);                   // íŒ¨í‚· ì ‘ê·¼
rte_eth_tx_burst(port_id, queue_id, &mbuf, 1);   // íŒ¨í‚· ì „ì†¡
```

------

### âœ… 3. XDP (eXpress Data Path)

#### ğŸ”¹ ê°œìš”

- ë¦¬ëˆ…ìŠ¤ ì»¤ë„ ë‚´ì— **eBPF í”„ë¡œê·¸ë¨**ì„ NICì— **ê°€ì¥ ê°€ê¹ê²Œ ì‹¤í–‰**í•˜ëŠ” ê¸°ìˆ 
- `kernel bypass`ëŠ” ì•„ë‹ˆê³ , `kernel fastpath`ì— í•´ë‹¹

#### ğŸ”¹ ë™ì‘ ìœ„ì¹˜

```
[NIC] â†’ [XDP/eBPF] â†’ drop / pass / redirect
```

- ì»¤ë„ **L2/L3 ìŠ¤íƒ ì§„ì… ì „**ì— ì²˜ë¦¬
- `drop`, `tx`, `pass`, `redirect`, `abort` ë“±ì˜ ì•¡ì…˜ ì œê³µ

------

#### ğŸ”¹ XDP ì¥ì 

| í•­ëª©                    | ì„¤ëª…                            |
| ----------------------- | ------------------------------- |
| ë¹ ë¥¸ ì‹¤í–‰ ì†ë„          | NIC ìˆ˜ì‹  ì§í›„ eBPF ì‹¤í–‰         |
| ì»¤ë„ ê¸°ëŠ¥ ì‚¬ìš© ê°€ëŠ¥     | í•„ìš” ì‹œ netfilter, tc ë“±ê³¼ ì—°ê³„ |
| í•„í„°ë§/í†µê³„ ëª©ì ì— ê°•í•¨ | DDoS ì°¨ë‹¨, í†µê³„ ìˆ˜ì§‘ì— ì í•©     |
| ì „ìš© ë“œë¼ì´ë²„ í•„ìš” ì—†ìŒ | ëŒ€ë¶€ë¶„ì˜ ì»¤ë„ì—ì„œ ì‚¬ìš© ê°€ëŠ¥     |

------

#### ğŸ”¹ ê°„ë‹¨í•œ eBPF/XDP í”„ë¡œê·¸ë¨ íë¦„ (C ì½”ë“œ ê¸°ë°˜)

```
SEC("xdp")
int xdp_prog(struct xdp_md *ctx) {
    void *data = (void *)(long)ctx->data;
    void *data_end = (void *)(long)ctx->data_end;

    struct ethhdr *eth = data;
    if (data + sizeof(*eth) > data_end)
        return XDP_ABORTED;

    if (eth->h_proto == htons(ETH_P_IP))
        return XDP_PASS;  // í†µê³¼
    else
        return XDP_DROP;  // ì°¨ë‹¨
}
```

ì»´íŒŒì¼ í›„ `ip link set dev eth0 xdp obj myprog.o` ì‹ìœ¼ë¡œ NICì— ë°”ì¸ë”©

------

### âœ… 4. DPDK vs XDP ë¹„êµ

| í•­ëª©        | **DPDK**                            | **XDP/eBPF**                             |
| ----------- | ----------------------------------- | ---------------------------------------- |
| ì†ë„        | ë§¤ìš° ë¹ ë¦„ (1000ë§Œ PPS ì´ìƒ)         | ë¹ ë¦„ (Î¼s ë‹¨ìœ„)                           |
| ìœ„ì¹˜        | ì™„ì „ ìœ ì € ê³µê°„                      | ì»¤ë„ ì§„ì… ì§í›„                           |
| ëª©ì         | ê³ ì† íŒ¨í‚· ì²˜ë¦¬, íŠ¸ë˜í”½ ì—”ì§„         | í•„í„°ë§, í†µê³„, ë³´ì•ˆ                       |
| ì‚¬ìš© ë‚œì´ë„ | ë†’ìŒ (NIC ë“œë¼ì´ë²„, HugePages í•„ìš”) | ë‚®ìŒ (í‘œì¤€ ì»¤ë„ë§Œìœ¼ë¡œ ê°€ëŠ¥)              |
| NIC ì œí•œ    | íŠ¹ì • ë“œë¼ì´ë²„ë§Œ ì‚¬ìš© ê°€ëŠ¥ (`vfio`)  | ëŒ€ë¶€ë¶„ ë“œë¼ì´ë²„ ì§€ì› (`mlx, ixgbe, ...`) |

------

### âœ… 5. ì‹¤ì „ ì ìš© ì˜ˆì‹œ

| ë¶„ì•¼             | ì ìš© ë°©ì‹                   |
| ---------------- | --------------------------- |
| IDS/Firewall     | XDPë¡œ ì˜ì‹¬ íŒ¨í‚· ë¹ ë¥´ê²Œ ì°¨ë‹¨ |
| DDoS ë°©ì–´        | XDP í”„ë¡œê·¸ë¨ìœ¼ë¡œ drop ì²˜ë¦¬  |
| íŒ¨í‚· ìƒì„±/ìŠ¤í‘¸í•‘ | DPDKë¡œ ì§ì ‘ íŒ¨í‚· ì¡°ì‘       |
| ë²¤ì¹˜ë§ˆí¬ ë„êµ¬    | DPDK + custom app           |
| Load balancer    | XDP + eBPF redirect         |

------

### âœ… 6. ì°¸ê³  ë„êµ¬

- DPDK ì˜ˆì œ: `/usr/share/dpdk/examples/*`
- XDP íŠœí† ë¦¬ì–¼: https://github.com/xdp-project
- DPDK ì„±ëŠ¥ ì¸¡ì •: `testpmd`, `pktgen`

## 14.5 IoT ë””ë°”ì´ìŠ¤ ë„¤íŠ¸ì›Œí¬ ì—°ë™ (C ê¸°ë°˜ TCP/IP Stack ë‚´ì¥)

### ğŸ¯ í•™ìŠµ ëª©í‘œ

ì†Œí˜• IoT ë””ë°”ì´ìŠ¤(ì„¼ì„œ, MCU, ë¬´ì„  ëª¨ë“ˆ ë“±)ëŠ” ì¼ë°˜ ë¦¬ëˆ…ìŠ¤ ì»¤ë„ì´ë‚˜ OSë¥¼ ì“°ì§€ ëª»í•˜ë¯€ë¡œ,
 ë„¤íŠ¸ì›Œí¬ ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ê¸° ìœ„í•´ ìì²´ ë‚´ì¥ TCP/IP ìŠ¤íƒì´ í•„ìš”í•˜ë‹¤.
 ì´ ì ˆì—ì„œëŠ” **ê²½ëŸ‰ TCP/IP ìŠ¤íƒ (uIP, lwIP)** ì„ C ì–¸ì–´ë¡œ IoT ì¥ë¹„ì— ì—°ë™í•˜ëŠ” ë°©ë²•ì„ í•™ìŠµí•œë‹¤.

------

### âœ… 1. ì™œ ê²½ëŸ‰ TCP/IP ìŠ¤íƒì´ í•„ìš”í•œê°€?

#### ì¼ë°˜ ë¦¬ëˆ…ìŠ¤ vs IoT MCU ì°¨ì´

| í•­ëª©           | ë¦¬ëˆ…ìŠ¤ ì‹œìŠ¤í…œ | IoT MCU (STM32 ë“±)  |
| -------------- | ------------- | ------------------- |
| OS ì¡´ì¬        | Linux ì»¤ë„    | ë³´í†µ ì—†ìŒ ë˜ëŠ” RTOS |
| ë©”ëª¨ë¦¬         | ìˆ˜ì‹­ MB~GB    | ìˆ˜ì‹­ KB~ìˆ˜ MB       |
| ì‹œìŠ¤í…œ ì½œ      | ì‚¬ìš© ê°€ëŠ¥     | ì—†ìŒ                |
| BSD Socket API | ì‚¬ìš© ê°€ëŠ¥     | ì§ì ‘ êµ¬í˜„í•´ì•¼ í•¨    |

#### â¤ ê·¸ë˜ì„œ **ì†Œí˜• C ê¸°ë°˜ TCP/IP ìŠ¤íƒì„ MCUì— í¬íŒ…**í•´ì•¼ í•œë‹¤.

------

### âœ… 2. ëŒ€í‘œì ì¸ ê²½ëŸ‰ TCP/IP ìŠ¤íƒ

| ìŠ¤íƒ ì´ë¦„                           | ì„¤ëª…                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| **uIP**                             | 8/16ë¹„íŠ¸ MCUìš©ìœ¼ë¡œ ë§Œë“  ì´ˆê²½ëŸ‰ TCP/IP ìŠ¤íƒ                   |
| **lwIP**                            | FreeRTOS ë“±ê³¼ ìì£¼ í•¨ê»˜ ì“°ì´ë©°, TCP/UDP/IPv4/IPv6, HTTP ì§€ì› |
| **CycloneTCP**                      | ìƒì—…ì /ì‚°ì—…ìš© ëª©ì ì˜ ì•ˆì •ì  ìŠ¤íƒ                             |
| **nanoIP**, **uC/TCP-IP** ë“±ë„ ìˆìŒ |                                                              |

------

### âœ… 3. lwIP ê°œìš” ë° êµ¬ì¡°

#### ğŸ”¹ êµ¬ì¡°ë„

```
[ Application (C code) ]
         â†“
 [ lwIP API (sockets / raw API) ]
         â†“
[ lwIP Core (tcp, udp, ip, dhcp) ]
         â†“
[ HAL ë“œë¼ì´ë²„ (eth, wifi ë“±) ]
```

#### ğŸ”¹ ì£¼ìš” êµ¬ì„± ëª¨ë“ˆ

- `tcp.c`, `udp.c`, `ip.c`, `netif.c` ë“±
- ì¸í„°í˜ì´ìŠ¤ ë“œë¼ì´ë²„: `netif/ethernetif.c`, `low_level_output()`

------

### âœ… 4. lwIP ì‚¬ìš© ë°©ì‹

#### ì„¤ì¹˜ (ì¼ë°˜ì ìœ¼ë¡œëŠ” ì§ì ‘ í¬íŒ…)

- STM32CubeMX â†’ **LWIP Enable** ì²´í¬ â†’ ìë™ ìƒì„±

#### ì¸í„°í˜ì´ìŠ¤ êµ¬ì„±

- ì¸í„°í˜ì´ìŠ¤ ì´ˆê¸°í™”: `netif_add()`
- íŒ¨í‚· ìˆ˜ì‹  í›„ ì…ë ¥ íì— ì‚½ì…: `netif_input()`
- ì†¡ì‹  ì‹œ í•˜ë“œì›¨ì–´ ì „ì†¡ í•¨ìˆ˜ í˜¸ì¶œ: `low_level_output()`

#### ë©”ì¸ ë£¨í”„ ì˜ˆì‹œ (No OS ëª¨ë“œ)

```
void main_loop() {
    struct pbuf* p;
    while (1) {
        p = ethernet_input(); // NICë¡œë¶€í„° ì§ì ‘ ìˆ˜ì‹ 
        if (p != NULL) {
            if (netif.input(p, &netif) != ERR_OK)
                pbuf_free(p);
        }
        sys_check_timeouts(); // íƒ€ì´ë¨¸ ê´€ë¦¬
    }
}
```

------

### âœ… 5. TCP ì„œë²„ ì˜ˆì œ (`lwip/tcp_echo.c`)

```
static err_t recv_cb(void* arg, struct tcp_pcb* tpcb, struct pbuf* p, err_t err) {
    if (!p) return ERR_OK;
    tcp_write(tpcb, p->payload, p->len, TCP_WRITE_FLAG_COPY);
    pbuf_free(p);
    return ERR_OK;
}

void tcp_echo_init(void) {
    struct tcp_pcb* pcb = tcp_new();
    tcp_bind(pcb, IP_ADDR_ANY, 1234);
    pcb = tcp_listen(pcb);
    tcp_accept(pcb, [](void* arg, struct tcp_pcb* newpcb, err_t err) {
        tcp_recv(newpcb, recv_cb);
        return ERR_OK;
    });
}
```

------

### âœ… 6. ì—°ê²°ëœ í•˜ë“œì›¨ì–´ ê³„ì¸µ ì—°ë™

- STM32, ESP32, NRF52 ë“± MCUì—ì„œëŠ” ì•„ë˜ ê³„ì¸µ í•„ìš”:

```
[ lwIP TCP/IP ]
     â†‘
[ Ethernet HAL ] â† `HAL_ETH_Transmit`, `HAL_ETH_GetReceivedFrame`
     â†‘
[ DMA/PHY/Driver ]
```

- RTOS ì—†ì´ë„ ë™ì‘ ê°€ëŠ¥ (`NO_SYS=1` ì„¤ì • ì‹œ)

------

### âœ… 7. ì‹¤ì „ ì˜ˆ: STM32 + lwIP + DHCP + ping

- STM32CubeMXì—ì„œ:
  - `LWIP enabled`
  - `DHCP client enabled`
- ì½”ë“œ:

```
MX_LWIP_Init(); // ìë™ ìƒì„±ëœ ì´ˆê¸°í™” ì½”ë“œ
while (1) {
  MX_LWIP_Process();  // Polling ê¸°ë°˜ lwIP ì²˜ë¦¬
}
```

- IP í• ë‹¹ â†’ ping â†’ TCP ì ‘ì† ê°€ëŠ¥

------

### âœ… 8. í™•ì¥ ì‘ìš©

| ê¸°ëŠ¥         | ë°©ë²•                          |
| ------------ | ----------------------------- |
| HTTP ì„œë²„    | `httpd.c` ë‚´ì¥                |
| MQTT Client  | `lwip/apps/mqtt`              |
| TLS/HTTPS    | mbedTLSì™€ ì—°ë™                |
| DNS/DHCP/NTP | ë³„ë„ ì˜µì…˜ í™œì„±í™”              |
| OTA ì—…ë°ì´íŠ¸ | TFTP ë˜ëŠ” HTTP ê¸°ë°˜ ì „ì†¡ ì²˜ë¦¬ |

------

### âœ… 9. ê³ ê¸‰ ê°œë°œ íŒ

- `pbuf` êµ¬ì¡°ëŠ” ë²„í¼ ì²´ì¸ìœ¼ë¡œ êµ¬ì„±ë¨ â†’ í¬ì¸í„° í•´ì œ ì£¼ì˜
- TCP ì„¸ì…˜ ìœ ì§€ ìœ„í•´ `tcp_poll`, `tcp_sent` ì´ë²¤íŠ¸ë„ ë“±ë¡ í•„ìš”
- ì¸í„°ëŸ½íŠ¸ ë‚´ì—ì„œ ì§ì ‘ `tcp_write()` ì‚¬ìš© ê¸ˆì§€ â†’ ì´ë²¤íŠ¸ í í™œìš©
- ë©”ëª¨ë¦¬ í’€ì´ ë¶€ì¡±í•  ê²½ìš° `MEM_SIZE`, `PBUF_POOL_SIZE` ì¡°ì •