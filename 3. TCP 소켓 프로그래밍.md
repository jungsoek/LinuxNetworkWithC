# 3. TCP μ†μΌ“ ν”„λ΅κ·Έλλ°

## 3.1 TCP μ„λ²„ κµ¬ν„ (λ‹¨μΌ μ ‘μ†)

### β… μ„λ²„μ κΈ°λ³Έ νλ¦„ μ”μ•½

```
1. socket()   β†’ μ†μΌ“ μƒμ„±
2. bind()     β†’ IPμ™€ ν¬νΈμ— λ°”μΈλ”©
3. listen()   β†’ μμ‹  λ€κΈ° μƒνƒ μ§„μ…
4. accept()   β†’ ν΄λΌμ΄μ–ΈνΈ μ ‘μ† μλ½ (μƒ μ†μΌ“ λ°ν™)
5. recv()/send() β†’ λ°μ΄ν„° μ†΅μμ‹ 
6. close()    β†’ μ—°κ²° μΆ…λ£
```

------

### β… μ „μ²΄ μμ  μ½”λ“

```
// tcp_server_single.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 12345
#define BUFFER_SIZE 1024

int main() {
    int server_fd, client_fd;
    struct sockaddr_in server_addr, client_addr;
    socklen_t addr_len = sizeof(client_addr);
    char buffer[BUFFER_SIZE] = {0};

    // 1. μ†μΌ“ μƒμ„±
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd < 0) {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }

    // 2. λ°”μΈλ”©
    memset(&server_addr, 0, sizeof(server_addr));  // κµ¬μ΅°μ²΄ μ΄κΈ°ν™”
    server_addr.sin_family = AF_INET;              // IPv4
    server_addr.sin_addr.s_addr = INADDR_ANY;      // 0.0.0.0 (λ¨λ“  IP ν—μ©)
    server_addr.sin_port = htons(PORT);            // ν¬νΈ λ²νΈ (λ„¤νΈμ›ν¬ λ°”μ΄νΈ μμ„)

    if (bind(server_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("bind failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    // 3. λ¦¬μ¤λ‹ μƒνƒ μ§„μ…
    if (listen(server_fd, 1) < 0) {
        perror("listen failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    printf("Waiting for connection on port %d...\n", PORT);

    // 4. ν΄λΌμ΄μ–ΈνΈ μ ‘μ† μλ½
    client_fd = accept(server_fd, (struct sockaddr *)&client_addr, &addr_len);
    if (client_fd < 0) {
        perror("accept failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    printf("Client connected: %s:%d\n",
           inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));

    // 5. λ°μ΄ν„° μμ‹  λ° μ‘λ‹µ
    int bytes_received = recv(client_fd, buffer, BUFFER_SIZE - 1, 0);
    if (bytes_received < 0) {
        perror("recv failed");
    } else {
        buffer[bytes_received] = '\0';  // λ„ μΆ…λ£
        printf("Received: %s\n", buffer);

        const char *reply = "Message received.\n";
        send(client_fd, reply, strlen(reply), 0);
    }

    // 6. μ—°κ²° μΆ…λ£
    close(client_fd);
    close(server_fd);
    printf("Connection closed.\n");

    return 0;
}
```

------

### β… ν…μ¤νΈ λ°©λ²•

#### 1. μ„λ²„ μ‹¤ν–‰

```
gcc tcp_server_single.c -o tcp_server_single
./tcp_server_single
```

#### 2. ν΄λΌμ΄μ–ΈνΈ μ—°κ²° (μ: netcat)

```
nc localhost 12345
```

> λ©”μ‹μ§€λ¥Ό μ…λ ¥ν•λ©΄ μ„λ²„κ°€ μμ‹  ν›„ μ‘λ‹µν•κ³  μΆ…λ£λΌ

------

### β… ν•µμ‹¬ μ²΄ν¬ν¬μΈνΈ

| κµ¬κ°„       | μ£Όμμ‚¬ν•­                                  |
| ---------- | ----------------------------------------- |
| `socket()` | μ‹¤ν¨ μ‹ errno ν™•μΈ (λ¦¬μ†μ¤ λ¶€μ΅± λ“±)       |
| `bind()`   | ν¬νΈ μ¤‘λ³µ λ°©μ§€ (`SO_REUSEADDR` ν™μ© κ°€λ¥) |
| `accept()` | μ‹¤μ  ν†µμ‹ μ€ `client_fd`λ΅ μν–‰            |
| `recv()`   | 0μ„ λ°ν™ν•λ©΄ μ—°κ²° μΆ…λ£ μλ―Έ               |
| `close()`  | μ„λ²„μ™€ ν΄λΌμ΄μ–ΈνΈ μ†μΌ“ λ¨λ‘ λ‹«κΈ°          |

------

### β… ν™•μ¥ μ•„μ΄λ””μ–΄

- λ΅κ·Έμ— `client_fd`, IP, ν¬νΈ μ¶λ ¥
- `fork()` νΉμ€ `pthread` κΈ°λ° λ‹¤μ¤‘ μ ‘μ† κµ¬μ΅°λ΅ ν™•μ¥ μμ •
- `select()` κΈ°λ° λ©€ν‹°ν”λ ‰μ‹± κµ¬μ΅°λ΅λ„ μ§„ν™” κ°€λ¥

## 3.2 TCP ν΄λΌμ΄μ–ΈνΈ κµ¬ν„

### β… ν΄λΌμ΄μ–ΈνΈ λ™μ‘ μμ„

```
1. socket() β†’ μ†μΌ“ μƒμ„±
2. connect() β†’ μ„λ²„μ— μ—°κ²°
3. send()/recv() β†’ λ°μ΄ν„° μ†΅μμ‹ 
4. close() β†’ μ—°κ²° μΆ…λ£
```

------

### β… μ „μ²΄ μμ  μ½”λ“

```
// tcp_client.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define SERVER_IP "127.0.0.1"
#define SERVER_PORT 12345
#define BUFFER_SIZE 1024

int main() {
    int sock;
    struct sockaddr_in server_addr;
    char buffer[BUFFER_SIZE];

    // 1. μ†μΌ“ μƒμ„±
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }

    // 2. μ„λ²„ μ£Όμ† μ„¤μ •
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);

    // IP μ£Όμ† λ¬Έμμ—΄μ„ λ°”μ΄λ„λ¦¬λ΅ λ³€ν™
    if (inet_pton(AF_INET, SERVER_IP, &server_addr.sin_addr) <= 0) {
        perror("inet_pton failed");
        close(sock);
        exit(EXIT_FAILURE);
    }

    // 3. μ„λ²„μ— μ—°κ²° μ”μ²­
    if (connect(sock, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("connect failed");
        close(sock);
        exit(EXIT_FAILURE);
    }

    printf("Connected to %s:%d\n", SERVER_IP, SERVER_PORT);

    // 4. λ©”μ‹μ§€ μ „μ†΅
    const char *msg = "Hello from client!";
    send(sock, msg, strlen(msg), 0);

    // 5. μ„λ²„λ΅λ¶€ν„° μ‘λ‹µ μμ‹ 
    int bytes_received = recv(sock, buffer, BUFFER_SIZE - 1, 0);
    if (bytes_received > 0) {
        buffer[bytes_received] = '\0';
        printf("Server replied: %s\n", buffer);
    }

    // 6. μ†μΌ“ λ‹«κΈ°
    close(sock);
    printf("Connection closed.\n");

    return 0;
}
```

------

### β… ν…μ¤νΈ λ°©λ²•

#### 1. μ„λ²„ μ‹¤ν–‰

λ¨Όμ € μ•μ„ λ§λ“  `tcp_server_single`μ„ μ‹¤ν–‰ν•΄.

```
./tcp_server_single
```

#### 2. ν΄λΌμ΄μ–ΈνΈ μ‹¤ν–‰

```
gcc tcp_client.c -o tcp_client
./tcp_client
```

> ν΄λΌμ΄μ–ΈνΈκ°€ "Hello from client!"λ¥Ό λ³΄λ‚΄κ³ , μ„λ²„λ” μ‘λ‹µμ„ λλ ¤μ¤€λ‹¤.

------

### β… μ£Όμν•  μ 

| λ‹¨κ³„        | μ²΄ν¬ν¬μΈνΈ                                               |
| ----------- | -------------------------------------------------------- |
| `connect()` | μ‹¤ν¨ μ‹ μ„λ²„κ°€ μΌμ Έ μλ”μ§€, IP/ν¬νΈκ°€ μ •ν™•ν•μ§€ ν™•μΈ      |
| `send()`    | λ°ν™κ°’μ€ μ‹¤μ  μ „μ†΅λ λ°”μ΄νΈ μ, `EPIPE`λ‚ `SIGPIPE` μ΅°μ‹¬ |
| `recv()`    | λ°ν™κ°’ 0 β†’ μ„λ²„κ°€ μΆ…λ£ν• κ²ƒ                              |
| `close()`   | μ—°κ²° μΆ…λ£ μ‹ λ°λ“μ‹ νΈμ¶                                 |

------

### β… ν™•μ¥ λ°©ν–¥

- ν΄λΌμ΄μ–ΈνΈκ°€ μ‚¬μ©μ μ…λ ¥μ„ λ°›μ•„ μ„λ²„μ— μ „μ†΅ν•κ² λ§λ“¤κΈ°
- μ„λ²„ μ£Όμ†λ¥Ό λ…λ Ήν–‰ μΈμλ΅ λ°›λ„λ΅ ν™•μ¥
- μ—¬λ¬ λ² μ†΅μμ‹  κ°€λ¥ν• κµ¬μ΅°λ΅ λ³€κ²½

## 3.3 λ‹¤μ¤‘ ν΄λΌμ΄μ–ΈνΈ μ²λ¦¬: `fork` κΈ°λ°

### β… κ°μ”

- `fork()`λ¥Ό ν†µν•΄ ν΄λΌμ΄μ–ΈνΈλ§λ‹¤ λ³„λ„μ μμ‹ ν”„λ΅μ„Έμ¤λ¥Ό μƒμ„±ν•¨
- κ° ν”„λ΅μ„Έμ¤λ” λ…λ¦½λ μ£Όμ† κ³µκ°„μ„ κ°€μ§€λ―€λ΅ μ•μ •μ 
- λ‹¨μ : ν”„λ΅μ„Έμ¤ μƒμ„± λΉ„μ©μ΄ λ†’κ³ , μμ‹ ν”„λ΅μ„Έμ¤ κ΄€λ¦¬κ°€ ν•„μ”ν•¨

------

### β… λ™μ‘ νλ¦„

```
1. socket()
2. bind()
3. listen()
4. accept() β†’ ν΄λΌμ΄μ–ΈνΈ μ—°κ²° μλ½
5. fork() β†’ μμ‹ ν”„λ΅μ„Έμ¤ μƒμ„±
   β”β”€ λ¶€λ¨: accept λ£¨ν”„λ΅ λμ•„κ°
   β””β”€ μμ‹: ν΄λΌμ΄μ–ΈνΈμ™€ ν†µμ‹  ν›„ μΆ…λ£
6. close()
```

------

### β… μμ  μ½”λ“

```
// tcp_server_fork.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/wait.h>
#include <signal.h>

#define PORT 12345
#define BUFFER_SIZE 1024

// μμ‹ ν”„λ΅μ„Έμ¤ μΆ…λ£ μ‹ μΆ€λΉ„ μ²λ¦¬ λ°©μ§€μ©
void handle_sigchld(int sig) {
    (void)sig;
    while (waitpid(-1, NULL, WNOHANG) > 0);
}

int main() {
    int server_fd, client_fd;
    struct sockaddr_in server_addr, client_addr;
    socklen_t addrlen = sizeof(client_addr);
    char buffer[BUFFER_SIZE];

    // μ‹κ·Έλ„ ν•Έλ“¤λ¬ λ“±λ΅ (μΆ€λΉ„ ν”„λ΅μ„Έμ¤ λ°©μ§€)
    signal(SIGCHLD, handle_sigchld);

    // 1. socket μƒμ„±
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd < 0) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 2. bind
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("bind");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    // 3. listen
    if (listen(server_fd, 10) < 0) {
        perror("listen");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    printf("Server listening on port %d...\n", PORT);

    // 4. λ£¨ν”„λ¥Ό λλ©° ν΄λΌμ΄μ–ΈνΈ μ²λ¦¬
    while (1) {
        client_fd = accept(server_fd, (struct sockaddr *)&client_addr, &addrlen);
        if (client_fd < 0) {
            perror("accept");
            continue;
        }

        pid_t pid = fork();
        if (pid == 0) {
            // μμ‹ ν”„λ΅μ„Έμ¤
            close(server_fd); // μμ‹μ€ μ„λ²„ μ†μΌ“ λ¶ν•„μ”

            int n = recv(client_fd, buffer, BUFFER_SIZE - 1, 0);
            if (n > 0) {
                buffer[n] = '\0';
                printf("Client: %s\n", buffer);
                send(client_fd, buffer, n, 0);
            }

            close(client_fd);
            exit(0); // μμ‹ μΆ…λ£
        } else if (pid > 0) {
            // λ¶€λ¨ ν”„λ΅μ„Έμ¤
            close(client_fd); // λ¶€λ¨λ” μ΄ ν΄λΌμ΄μ–ΈνΈ μ²λ¦¬ μ•ν•¨
        } else {
            perror("fork");
        }
    }

    close(server_fd);
    return 0;
}
```

------

### β… ν…μ¤νΈ λ°©λ²•

1. μ„λ²„ μ‹¤ν–‰:

```
gcc tcp_server_fork.c -o tcp_server_fork
./tcp_server_fork
```

1. ν΄λΌμ΄μ–ΈνΈλ¥Ό μ—¬λ¬ λ² μ‹¤ν–‰ν•κ±°λ‚ telnetμΌλ΅ μ ‘μ†:

```
telnet localhost 12345
```

------

### β… ν¬μΈνΈ μ •λ¦¬

| ν¬μΈνΈ           | μ„¤λ…                              |
| ---------------- | --------------------------------- |
| `fork()`         | ν΄λΌμ΄μ–ΈνΈλ§λ‹¤ λ³„λ„ ν”„λ΅μ„Έμ¤ μƒμ„± |
| `SIGCHLD` ν•Έλ“¤λ¬ | μΆ€λΉ„ ν”„λ΅μ„Έμ¤ μ κ±°                |
| λ¶€λ¨/μμ‹        | μ†μΌ“ μ—­ν•  λ¶„λ¦¬ λ…ν™•ν ν•΄μ•Ό ν•¨     |
| `close()` μ²λ¦¬   | κ°κ°μ μ†μΌ“μ„ μ •ν™•ν λ‹«μ•„μ•Ό ν•¨    |

------

### β… ν™•μ¥ λ°©ν–¥

- μμ‹ ν”„λ΅μ„Έμ¤μ—μ„ ν΄λΌμ΄μ–ΈνΈ μ”μ²­ λ°λ³µ μ²λ¦¬
- λ΅κΉ… λλ” νμΌ μ „μ†΅ κΈ°λ¥ μ¶”κ°€
- `waitpid()`λ¥Ό ν†µν• μμ‹ μƒνƒ κ°μ‹ κ°μ„ 

## 3.4 λ‹¤μ¤‘ ν΄λΌμ΄μ–ΈνΈ μ²λ¦¬: `pthread` κΈ°λ°

### π“ κ°μ”

- `fork()`μ™€ λ‹¬λ¦¬ **μ¤λ λ“λ” λ©”λ¨λ¦¬ κ³µκ°„μ„ κ³µμ **ν•κΈ° λ•λ¬Έμ— μƒμ„± λΉ„μ©μ΄ λ‚®κ³  μ„±λ¥μ΄ μ λ¦¬ν•¨.
- κ° ν΄λΌμ΄μ–ΈνΈ μ—°κ²°μ„ `pthread_create()`λ΅ **μƒ μ¤λ λ“μ— μ„μ„**ν•μ—¬ μ²λ¦¬.
- κ³µμ  μμ›μ— λ€ν• **λ™κΈ°ν™” μ΄μ**λ” μ§μ ‘ κ΄€λ¦¬ν•΄μ•Ό ν•¨.

------

### β… κµ¬μ΅° μ”μ•½

```
main() {
  socket();
  bind();
  listen();
  while (1) {
    accept();
    pthread_create(); // ν΄λΌμ΄μ–ΈνΈ μ²λ¦¬λ¥Ό μƒ μ¤λ λ“μ— μ„μ„
  }
}
μ¤λ λ“ ν•¨μ {
  recv/send λ°λ³µ;
  close();
  pthread_exit();
}
```

------

### β… μμ  μ½”λ“

```
// tcp_server_pthread.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <arpa/inet.h>

#define PORT 12345
#define BUFFER_SIZE 1024

void *handle_client(void *arg) {
    int client_fd = *(int *)arg;
    free(arg);  // λ™μ μΌλ΅ ν• λ‹Ήν• ν¬μΈν„° ν•΄μ 
    char buffer[BUFFER_SIZE];

    int n = recv(client_fd, buffer, BUFFER_SIZE - 1, 0);
    if (n > 0) {
        buffer[n] = '\0';
        printf("Client: %s\n", buffer);
        send(client_fd, buffer, n, 0); // Echo back
    }

    close(client_fd);
    pthread_exit(NULL);
}

int main() {
    int server_fd, *client_fd;
    struct sockaddr_in server_addr, client_addr;
    socklen_t addrlen = sizeof(client_addr);

    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd < 0) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("bind");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    if (listen(server_fd, 10) < 0) {
        perror("listen");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    printf("Server listening on port %d...\n", PORT);

    while (1) {
        client_fd = malloc(sizeof(int));
        if (!client_fd) {
            perror("malloc");
            continue;
        }

        *client_fd = accept(server_fd, (struct sockaddr *)&client_addr, &addrlen);
        if (*client_fd < 0) {
            perror("accept");
            free(client_fd);
            continue;
        }

        pthread_t tid;
        if (pthread_create(&tid, NULL, handle_client, client_fd) != 0) {
            perror("pthread_create");
            close(*client_fd);
            free(client_fd);
            continue;
        }

        pthread_detach(tid); // μ¤λ λ“ λ¦¬μ†μ¤ μλ™ νμ
    }

    close(server_fd);
    return 0;
}
```

------

### β… μ£Όμ” ν¬μΈνΈ μ •λ¦¬

| ν•­λ©               | μ„¤λ…                                   |
| ------------------ | -------------------------------------- |
| `pthread_create()` | ν΄λΌμ΄μ–ΈνΈ μ²λ¦¬μ© μ¤λ λ“ μƒμ„±          |
| `pthread_detach()` | μ¤λ λ“ μΆ…λ£ μ‹ μλ™μΌλ΅ μμ› νμ      |
| `client_fd`        | ν™μ— λ™μ  ν• λ‹Ήν•΄μ„ race condition λ°©μ§€ |
| `handle_client()`  | ν΄λΌμ΄μ–ΈνΈμ™€ ν†µμ‹  μ²λ¦¬ λ‹΄λ‹Ή            |

------

### β… ν…μ¤νΈ λ°©λ²•

1. μ„λ²„ μ»΄νμΌ λ° μ‹¤ν–‰:

```
gcc tcp_server_pthread.c -o tcp_server_pthread -lpthread
./tcp_server_pthread
```

1. μ—¬λ¬ κ°μ `telnet` λλ” ν΄λΌμ΄μ–ΈνΈλ΅ μ ‘μ†ν•΄λ³΄λ©΄, κ°κ°μ μ—°κ²°μ΄ λ³„λ„μ μ¤λ λ“μ—μ„ μ²λ¦¬λ¨.

------

### β… ν™•μ¥ ν¬μΈνΈ

- `read`/`write` λ°λ³µ λ£¨ν”„ β†’ μ§€μ†μ μΈ μ„λΉ„μ¤λ΅ ν™•μ¥
- `thread pool` λ°©μ‹μΌλ΅ λ³€κ²½ (μ„±λ¥ μµμ ν™”)
- mutexλ‚ semaphoreλ¥Ό μ΄μ©ν• κ³µμ μμ› μ μ–΄

## 3.5 μ ‘μ† λκΉ€, μ¤λ¥ μ²λ¦¬, μΆ…λ£ μ²λ¦¬

### π“ 1. μ ‘μ† λκΉ€μ μΆ…λ¥

| κµ¬λ¶„          | μ„¤λ…                                                   |
| ------------- | ------------------------------------------------------ |
| μ •μƒ μΆ…λ£     | ν΄λΌμ΄μ–ΈνΈκ°€ `close()` λλ” `shutdown()`μ„ νΈμ¶        |
| λΉ„μ •μƒ μΆ…λ£   | ν”„λ΅μ„Έμ¤ κ°•μ  μΆ…λ£ (`kill`, `crash`, λ„¤νΈμ›ν¬ μ¥μ•  λ“±) |
| νƒ€μ„μ•„μ›ƒ μΆ…λ£ | μ¥μ‹κ°„ μ‘λ‹µ μ—†μ β†’ μ„λ²„κ°€ κ°•μ λ΅ μ—°κ²° μΆ…λ£             |

------

### π“ 2. κ°μ§€ λ°©μ‹: `recv()` λ°ν™κ°’μΌλ΅ ν™•μΈ

```
int n = recv(sock, buf, sizeof(buf), 0);

if (n > 0) {
    // μ •μƒ λ°μ΄ν„° μμ‹ 
} else if (n == 0) {
    // μƒλ€λ°©μ΄ "μ •μƒμ μΌλ΅ μ—°κ²° μΆ…λ£" (close)
} else {
    // μ¤λ¥ λ°μƒ
    perror("recv");
}
```

------

### π“ 3. `errno` κ°’μ— λ”°λ¥Έ μ¤λ¥ μ‹λ³„

```
#include <errno.h>

if (recv(...) < 0) {
    if (errno == EINTR) {
        // μ‹κ·Έλ„μ— μν•΄ μΈν„°λ½νΈλ¨ β†’ μ¬μ‹λ„ κ°€λ¥
    } else if (errno == EWOULDBLOCK || errno == EAGAIN) {
        // λ…ΌλΈ”λ΅ν‚Ή μ†μΌ“μ—μ„ λ°μ΄ν„° μ—†μ β†’ κΈ°λ‹¤λ¦¬κΈ°
    } else {
        // κΈ°νƒ€ μ¤λ¥ β†’ μ—°κ²° μΆ…λ£
    }
}
```

------

### π“ 4. ν΄λΌμ΄μ–ΈνΈ κ°•μ  μΆ…λ£μ κ°μ§€

- ν΄λΌμ΄μ–ΈνΈκ°€ κ°•μ λ΅ μΆ…λ£λλ©΄ μ„λ²„λ” **recv() β†’ -1**, λλ” **send() μ‹ SIGPIPE** λ°μƒ
- λ°©μ§€ λ°©λ²•:

```
// send()μ—μ„ SIGPIPE λ°©μ§€
send(sock, buf, len, MSG_NOSIGNAL);

// λλ” μ „μ—­μ μΌλ΅ λ¬΄μ‹
signal(SIGPIPE, SIG_IGN);
```

------

### π“ 5. `SO_LINGER`λ΅ μΆ…λ£ μ‹λ„ μ μ–΄

- `close()` νΈμ¶ μ‹ **μ†΅μ‹  λ²„νΌκ°€ λΉ„μ›μ§€κΈΈ κΈ°λ‹¤λ¦΄μ§€ μ—¬λ¶€** μ„¤μ •
- κ°•μ λ΅ RST λ³΄λ‚΄μ„ μ¦‰μ‹ μΆ…λ£ν•  μλ„ μμ

```
struct linger sl;
sl.l_onoff = 1;
sl.l_linger = 0;
setsockopt(sock, SOL_SOCKET, SO_LINGER, &sl, sizeof(sl));
```

------

### π“ 6. μμ™Έ μƒν™© μ²λ¦¬ μ „λµ

| μƒν™©                          | μ²λ¦¬ μ „λµ                                           |
| ----------------------------- | --------------------------------------------------- |
| ν΄λΌμ΄μ–ΈνΈκ°€ μκ³  μ—†μ΄ μΆ…λ£λ¨ | `recv() == 0` μ²λ¦¬ λ° λ¦¬μ†μ¤ ν•΄μ                    |
| `send()` μ¤‘ SIGPIPE           | `MSG_NOSIGNAL` μµμ… λλ” `signal(SIGPIPE, SIG_IGN)` |
| κ³Όλ„ν• ν΄λΌμ΄μ–ΈνΈ μ ‘μ†        | `listen()` ν ν™•μ¥ λλ” μ ‘μ† μ ν• λ΅μ§ κµ¬ν„         |
| μ¤λ λ“/ν”„λ΅μ„Έμ¤ λ„μ          | `pthread_detach()`, `waitpid()`λ΅ νμ              |

------

### π“ 7. μμ  μ½”λ“ μ΅°κ°

```
char buf[1024];
int n = recv(client_fd, buf, sizeof(buf), 0);
if (n == 0) {
    printf("ν΄λΌμ΄μ–ΈνΈκ°€ μ—°κ²°μ„ μΆ…λ£ν–μµλ‹λ‹¤.\n");
    close(client_fd);
} else if (n < 0) {
    perror("recv μ‹¤ν¨");
    close(client_fd);
}
```

------

### π“ 8. μΆ…λ£ μ‹ λ¦¬μ†μ¤ μ •λ¦¬ μ²΄ν¬λ¦¬μ¤νΈ

- `close(socket_fd)` μν–‰
- μ¤λ λ“λΌλ©΄ `pthread_exit()` λλ” ν•¨μ return
- `malloc()` ν–λ μμ› `free()`
- μƒνƒ λ΅κ·Έ μ €μ¥ λλ” ν΄λ¦°μ—… ν•Έλ“¤λ¬ λ“±λ΅

------

### β… μ •λ¦¬ μ”μ•½ν‘

| ν•­λ©           | μ£Όμ” μ²λ¦¬ λ°©λ²•                          |
| -------------- | --------------------------------------- |
| μ—°κ²° μΆ…λ£ κ°μ§€ | `recv() == 0`, `send()` μ¤λ¥, `SIGPIPE` |
| μ¤λ¥ λ³µκµ¬      | `errno`μ— λ”°λΌ μ¬μ‹λ„ λλ” μ—°κ²° μΆ…λ£    |
| μμ› νμ      | `close()`, `free()`, `pthread_detach()` |
| κ°•μ  μΆ…λ£      | `SO_LINGER` μ„¤μ • λλ” `shutdown()`      |
| λ³΄μ•μ  μΆ…λ£    | λ¬΄μ‘λ‹µ ν΄λΌμ΄μ–ΈνΈμ— `timeout` μ •μ±… μ μ© |

## 3.6 TCP μ—°κ²° μ μ§€ (`keep-alive`, `SO_LINGER` μµμ…)

### π“ 1. TCP μ—°κ²° μƒνƒμ™€ νƒ€μ„μ•„μ›ƒ κ°μ”

TCP μ—°κ²°μ€ μƒνƒ κΈ°λ°(Stateful) ν”„λ΅ν† μ½μ΄λΌ,

- μ—°κ²°μ΄ μ μ§€λλ” λ™μ• μ‹μ¤ν… μμ›μ„ μ μ ν•¨
- ν΄λΌμ΄μ–ΈνΈκ°€ μΆ…λ£λ¥Ό μ•λ¦¬μ§€ μ•μΌλ©΄ "μ λ Ή μ—°κ²°(zombie)"μ΄ λ°μƒν•  μ μμ

μ΄λ¥Ό ν•΄κ²°ν•λ ¤λ©΄:

- λΉ„μ •μƒ μ—°κ²°μ„ **μλ™μΌλ΅ κ°μ§€ν•κ³  μΆ…λ£**
- μ—°κ²° μΆ…λ£ μ‹ **λ°μ΄ν„° μ†μ‹¤ μ—†μ΄ λ§λ¬΄λ¦¬**

------

### β… 2. `SO_KEEPALIVE`: μ ν΄ μ—°κ²° μƒμ΅΄ κ°μ‹

#### π“ λ©μ 

- μ¥μ‹κ°„ **μ ν΄ μƒνƒμΈ TCP μ—°κ²°**μ„ κ°μ§€ν•κ³  κ°•μ  μΆ…λ£
- μƒλ€λ°©μ΄ μ£½μ—λ”μ§€ κ°μ§€ν•λ” μ—­ν•  (pingκ³Ό μ μ‚¬)

#### π“ μ‚¬μ©λ²•

```
int optval = 1;
setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof(optval));
```

#### π“ λ™μ‘ λ©”μ»¤λ‹μ¦ (λ¦¬λ…μ¤ κΈ°λ³Έκ°’ κΈ°μ¤€)

| ν•­λ©                   | μ„¤λ…                       | κΈ°λ³Έκ°’         |
| ---------------------- | -------------------------- | -------------- |
| `tcp_keepalive_time`   | μ ν΄ μ‹κ°„ ν›„ μ²« probe μ „μ†΅ | 7200μ΄ (2μ‹κ°„) |
| `tcp_keepalive_intvl`  | probe κ°„ κ°„κ²©              | 75μ΄           |
| `tcp_keepalive_probes` | μ‹¤ν¨ ν—μ© νμ             | 9ν            |

> μ¦‰, μ•„λ¬΄λ° λ°μ΄ν„°λ„ μ¤κ°€μ§€ μ•μΌλ©΄ 2μ‹κ°„ ν›„ probe μ‹μ‘ β†’ 75μ΄ κ°„κ²©μΌλ΅ 9νκΉμ§€ μ‹λ„ β†’ μ‹¤ν¨ μ‹ `recv()`κ°€ 0μ„ λ°ν™ν•κ³  μ—°κ²° μΆ…λ£

#### π“ μ»¤λ„ νλΌλ―Έν„° λ³€κ²½

```
echo 60 > /proc/sys/net/ipv4/tcp_keepalive_time
echo 10 > /proc/sys/net/ipv4/tcp_keepalive_intvl
echo 5  > /proc/sys/net/ipv4/tcp_keepalive_probes
```

λλ” `/etc/sysctl.conf`μ— μ„¤μ • ν›„ `sysctl -p`

------

### β… 3. `SO_LINGER`: μΆ…λ£ μ‹ λ°μ΄ν„° μ²λ¦¬ λ°©μ‹ μ μ–΄

#### π“ κΈ°λ³Έ λ™μ‘

```
close(sock);
```

- λ‚΄λ¶€μ μΌλ΅λ” `FIN` μ „μ†΅
- **μ „μ†΅ νμ— λ‚¨μ€ λ°μ΄ν„°κ°€ μμΌλ©΄** μ „μ†΅ μ™„λ£κΉμ§€ λΈ”λ΅ν‚Ήλ¨

#### π“ `SO_LINGER` μµμ…μΌλ΅ μ»¤μ¤ν„°λ§μ΄μ§•

```
struct linger sl;
sl.l_onoff = 1;     // SO_LINGER ν™μ„±ν™”
sl.l_linger = 0;    // 0μ΄ λ€κΈ°: RST μ „μ†΅ (μ¦‰μ‹ μΆ…λ£)
setsockopt(sock, SOL_SOCKET, SO_LINGER, &sl, sizeof(sl));
```

| μ„¤μ •                  | λ™μ‘                                                       |
| --------------------- | ---------------------------------------------------------- |
| `onoff=0`             | κΈ°λ³Έκ°’, graceful close (κΈ°λ‹¤λ¦Ό)                            |
| `onoff=1`, `linger>0` | linger μ΄λ§νΌ κΈ°λ‹¤λ¦Ό (νƒ€μ„μ•„μ›ƒ μ•μ— μ „μ†΅ μ•λλ©΄ κ°•μ  μΆ…λ£) |
| `onoff=1`, `linger=0` | μ¦‰μ‹ `RST` μ „μ†΅ (μ—°κ²° μ¦‰μ‹ μΆ…λ£)                           |

------

### π“ 4. μ‹¤λ¬΄ μ μ© μ „λµ

| μ‹λ‚λ¦¬μ¤                                | μ¶”μ² μ„¤μ •                                  |
| --------------------------------------- | ------------------------------------------ |
| μ„λ²„κ°€ ν΄λΌμ΄μ–ΈνΈ λΉ„μ •μƒ μΆ…λ£ κ°μ§€ ν•„μ” | `SO_KEEPALIVE` ν™μ„±ν™”                      |
| λ€μ©λ‰ μ „μ†΅ ν›„ λΉ λ¥Έ μΆ…λ£κ°€ ν•„μ”         | `SO_LINGER` with linger > 0                |
| μ—λ¬λ‚ κ³µκ²© μƒν™©μ—μ„ μ¦‰μ‹ μ—°κ²° μ κ±°     | `SO_LINGER` with linger = 0                |
| μΌλ° μ›Ή μ„λ²„                            | `SO_KEEPALIVE` λΉ„ν™μ„±ν™” (HTTPλ” λ‹¨κΈ° μ—°κ²°) |

------

### π§ μμ  μ½”λ“

```
// keep-alive ν™μ„±ν™”
int optval = 1;
setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof(optval));

// linger μ„¤μ •
struct linger so_linger = { .l_onoff = 1, .l_linger = 5 };
setsockopt(sock, SOL_SOCKET, SO_LINGER, &so_linger, sizeof(so_linger));
```

------

### β… μ”μ•½ μ •λ¦¬

| μµμ…           | λ©μ                                | λΉ„κ³                       |
| -------------- | ---------------------------------- | ------------------------- |
| `SO_KEEPALIVE` | μ ν΄ μ—°κ²° μλ™ κ°μ§€ λ° μ •λ¦¬        | μ‹μ¤ν… νλΌλ―Έν„° μ΅°μ • κ°€λ¥ |
| `SO_LINGER`    | close μ‹μ μ— λ°μ΄ν„° μ²λ¦¬ λ°©μ‹ μ μ–΄ | μ¦‰μ‹ μΆ…λ£ κ°€λ¥ (`RST`)    |