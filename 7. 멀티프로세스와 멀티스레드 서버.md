# 7. ë©€í‹°í”„ë¡œì„¸ìŠ¤ì™€ ë©€í‹°ìŠ¤ë ˆë“œ ì„œë²„

## 7.1 `fork()` ê¸°ë°˜ ë‹¤ì¤‘ ì ‘ì† ì„œë²„

### ğŸ“˜ ê°œìš”

`fork()`ëŠ” í˜„ì¬ í”„ë¡œì„¸ìŠ¤ë¥¼ ë³µì œí•˜ì—¬ ìì‹ í”„ë¡œì„¸ìŠ¤ë¥¼ ìƒì„±í•˜ëŠ” ì‹œìŠ¤í…œ ì½œì´ë‹¤. ë„¤íŠ¸ì›Œí¬ ì„œë²„ì—ì„œ ì´ë¥¼ ì´ìš©í•˜ë©´, í´ë¼ì´ì–¸íŠ¸ ì ‘ì† ì‹œë§ˆë‹¤ ë³„ë„ì˜ ìì‹ í”„ë¡œì„¸ìŠ¤ë¥¼ ìƒì„±í•˜ì—¬ ë³‘ë ¬ ì²˜ë¦¬í•  ìˆ˜ ìˆë‹¤. ì´ëŠ” Unix ì „í†µì˜ ë‹¤ì¤‘ ì ‘ì† ì²˜ë¦¬ ë°©ì‹ì´ë©°, ì•ˆì •ì„±ì€ ë†’ì§€ë§Œ í”„ë¡œì„¸ìŠ¤ ìƒì„± ë¹„ìš©ì´ í¬ë‹¤ëŠ” ë‹¨ì ì´ ìˆë‹¤.

------

### âš™ï¸ êµ¬ì¡° ê°œìš”

- ë©”ì¸ ì„œë²„ í”„ë¡œì„¸ìŠ¤ëŠ” `socket()`, `bind()`, `listen()`ì„ ìˆ˜í–‰í•œ ë’¤, í´ë¼ì´ì–¸íŠ¸ ì ‘ì†ì„ ê°ì§€í•˜ë©´ `accept()` í˜¸ì¶œ
- `accept()` ì´í›„ `fork()`ë¡œ ìì‹ í”„ë¡œì„¸ìŠ¤ë¥¼ ìƒì„±í•˜ì—¬ í´ë¼ì´ì–¸íŠ¸ ìš”ì²­ì„ ì²˜ë¦¬
- ìì‹ì€ ì²˜ë¦¬ ì¢…ë£Œ í›„ ì¢…ë£Œí•˜ë©°, ë¶€ëª¨ëŠ” ê³„ì†í•´ì„œ ìƒˆ í´ë¼ì´ì–¸íŠ¸ ìš”ì²­ì„ ëŒ€ê¸°

------

### ğŸ“ ì•„í‚¤í…ì²˜ ë‹¤ì´ì–´ê·¸ë¨

```
           [Main Server Process]
                  â†“ listen
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚ accept()   â”‚â—„â”€â”
             â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ ë°˜ë³µ
                  â†“          â”‚
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
             â”‚ fork()     â”‚  â”‚
             â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
           parent â”‚      child
          continueâ”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚      â”‚ client ì²˜ë¦¬ â”‚
                  â†“      â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
               ë‹¤ìŒ ì—°ê²°        â†“
                            ì¢…ë£Œ (exit)
```

------

### ğŸ“š ì˜ˆì œ ì½”ë“œ

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <signal.h>

#define PORT 8080

void handle_client(int client_sock) {
    char buffer[1024];
    int n;
    while ((n = read(client_sock, buffer, sizeof(buffer))) > 0) {
        write(client_sock, buffer, n); // echo
    }
    close(client_sock);
}

int main() {
    int server_sock = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(PORT);
    addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_sock, (struct sockaddr*)&addr, sizeof(addr));
    listen(server_sock, 5);

    // ì¢€ë¹„ í”„ë¡œì„¸ìŠ¤ ë°©ì§€
    signal(SIGCHLD, SIG_IGN);

    while (1) {
        int client_sock = accept(server_sock, NULL, NULL);

        pid_t pid = fork();
        if (pid == 0) {
            // ìì‹ í”„ë¡œì„¸ìŠ¤
            close(server_sock); // ìì‹ì€ ì„œë²„ ì†Œì¼“ í•„ìš” ì—†ìŒ
            handle_client(client_sock);
            exit(0);
        } else {
            // ë¶€ëª¨ í”„ë¡œì„¸ìŠ¤
            close(client_sock); // ë¶€ëª¨ëŠ” client ì†Œì¼“ ë‹«ê¸°
        }
    }

    close(server_sock);
    return 0;
}
```

------

### ğŸ” ì£¼ìš” íŠ¹ì§• ìš”ì•½

| í•­ëª©      | ì„¤ëª…                                             |
| --------- | ------------------------------------------------ |
| ì²˜ë¦¬ ë‹¨ìœ„ | ì ‘ì†ë‹¹ í”„ë¡œì„¸ìŠ¤ 1ê°œ ìƒì„±                         |
| ìì› ê²©ë¦¬ | ê° í”„ë¡œì„¸ìŠ¤ëŠ” ë…ë¦½ëœ ì£¼ì†Œ ê³µê°„ ì‚¬ìš©              |
| ì•ˆì •ì„±    | ê°œë³„ ì ‘ì†ì´ ì¶©ëŒ ì‹œ ì „ì²´ ì„œë²„ ì˜í–¥ ì—†ìŒ          |
| ë‹¨ì       | í”„ë¡œì„¸ìŠ¤ ìƒì„±/í•´ì œ ë¹„ìš©ì´ í¼                     |
| ê°œì„  ë°©ì•ˆ | `prefork`, `thread pool`, `epoll` êµ¬ì¡° ë„ì… ê°€ëŠ¥ |

------

### ğŸ§  ì‹¤ë¬´ íŒ

- ë°˜ë“œì‹œ `SIGCHLD`ë¥¼ ì²˜ë¦¬í•˜ê±°ë‚˜ `signal(SIGCHLD, SIG_IGN)` ì„¤ì •ìœ¼ë¡œ ì¢€ë¹„ í”„ë¡œì„¸ìŠ¤ë¥¼ ë°©ì§€í•´ì•¼ í•œë‹¤.
- `fork()`ë¡œ ìƒì„±ëœ ìì‹ì€ ë¶ˆí•„ìš”í•œ ë¦¬ì†ŒìŠ¤(ì˜ˆ: ì„œë²„ ì†Œì¼“, íŒŒì¼ ë””ìŠ¤í¬ë¦½í„°)ë¥¼ ë°˜ë“œì‹œ ì •ë¦¬í•´ì•¼ í•œë‹¤.
- ë‹¤ìˆ˜ì˜ ë™ì‹œ ì ‘ì†ì´ ì˜ˆìƒë  ê²½ìš° `fork()`ëŠ” ì„±ëŠ¥ í•œê³„ê°€ ìˆìœ¼ë¯€ë¡œ `thread pool` ë˜ëŠ” `epoll` ê¸°ë°˜ ì²˜ë¦¬ë¡œì˜ í™•ì¥ì´ í•„ìš”í•˜ë‹¤.

## 7.2 `pthread` ê¸°ë°˜ ë©€í‹°ìŠ¤ë ˆë“œ ì„œë²„

### ğŸ“˜ ê°œìš”

`pthread`(POSIX thread)ëŠ” ë¦¬ëˆ…ìŠ¤ ë° ìœ ë‹‰ìŠ¤ ê³„ì—´ì—ì„œ ì‚¬ìš©í•˜ëŠ” ìŠ¤ë ˆë“œ ë¼ì´ë¸ŒëŸ¬ë¦¬ë‹¤. ë„¤íŠ¸ì›Œí¬ ì„œë²„ì—ì„œ `pthread`ë¥¼ ì‚¬ìš©í•˜ë©´, í´ë¼ì´ì–¸íŠ¸ ì ‘ì†ë§ˆë‹¤ ë³„ë„ì˜ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ì—¬ ë³‘ë ¬ ì²˜ë¦¬í•  ìˆ˜ ìˆë‹¤. ì´ëŠ” `fork()`ë³´ë‹¤ ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ì´ ì ê³  ë¹ ë¥´ë©°, ë©”ëª¨ë¦¬ë¥¼ ê³µìœ í•˜ë¯€ë¡œ í†µì‹  ì„±ëŠ¥ì´ ìš°ìˆ˜í•˜ë‹¤.

------

### ğŸ§± ì„¤ê³„ êµ¬ì¡° ìš”ì•½

- ë©”ì¸ ì„œë²„ëŠ” `accept()`ë¥¼ í†µí•´ í´ë¼ì´ì–¸íŠ¸ ì†Œì¼“ì„ íšë“
- í•´ë‹¹ ì†Œì¼“ì„ ìƒˆë¡œìš´ `pthread`ë¡œ ë„˜ê²¨ í´ë¼ì´ì–¸íŠ¸ ì²˜ë¦¬ ì „ë‹´
- ê° ìŠ¤ë ˆë“œëŠ” ë…ë¦½ì ìœ¼ë¡œ ìˆ˜ì‹ /ì‘ë‹µ ì²˜ë¦¬
- ì¢…ë£Œ ì‹œ ìŠ¤ë ˆë“œ ì¢…ë£Œ ë° ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ìˆ˜í–‰

------

### ğŸ“ êµ¬ì¡° íë¦„ë„

```
             [Main Server Thread]
                    â†“ accept
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚ client socket íšë“ â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â†“
           [pthread ìƒì„±]
                   â†“
        [Thread Function ì‹¤í–‰]
              â†“         â†“
           recv()     send()
              â†“         â†“
         close(fd)   pthread_exit()
```

------

#### ğŸ§ª ì˜ˆì œ ì½”ë“œ

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netinet/in.h>

#define PORT 8080

void* client_handler(void* arg) {
    int client_sock = *(int*)arg;
    free(arg);

    char buffer[1024];
    int n;
    while ((n = read(client_sock, buffer, sizeof(buffer))) > 0) {
        write(client_sock, buffer, n); // echo
    }

    close(client_sock);
    pthread_exit(NULL);
}

int main() {
    int server_sock = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(PORT);
    addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_sock, (struct sockaddr*)&addr, sizeof(addr));
    listen(server_sock, 10);

    while (1) {
        int* client_sock = malloc(sizeof(int));
        *client_sock = accept(server_sock, NULL, NULL);

        pthread_t tid;
        pthread_create(&tid, NULL, client_handler, client_sock);
        pthread_detach(tid); // ìë™ ìì› íšŒìˆ˜
    }

    close(server_sock);
    return 0;
}
```

------

#### ğŸ” êµ¬ì¡°ì  íŠ¹ì§• ìš”ì•½

| í•­ëª©        | ì„¤ëª…                                  |
| ----------- | ------------------------------------- |
| ì²˜ë¦¬ ë‹¨ìœ„   | ì ‘ì†ë‹¹ ìŠ¤ë ˆë“œ 1ê°œ ìƒì„±                |
| ì„±ëŠ¥        | `fork()`ë³´ë‹¤ ë¹ ë¥´ê³  ìì› íš¨ìœ¨ì        |
| ë©”ëª¨ë¦¬ ëª¨ë¸ | ë™ì¼ í”„ë¡œì„¸ìŠ¤ ê³µê°„ ê³µìœ                |
| ì£¼ì˜ì‚¬í•­    | ë™ì‹œì„± ì œì–´ í•„ìš” (mutex ë“±)           |
| ìì› í•´ì œ   | `pthread_detach()`ë¡œ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€ |

------

#### ğŸ§  ì‹¤ë¬´ ê³ ë ¤ì‚¬í•­

- ë™ì‹œ í´ë¼ì´ì–¸íŠ¸ ìˆ˜ê°€ ìˆ˜ì²œ ë‹¨ìœ„ ì´ìƒì´ë©´ `pthread`ë³´ë‹¤ëŠ” **ìŠ¤ë ˆë“œ í’€** ë˜ëŠ” `epoll` ê¸°ë°˜ êµ¬ì¡°ê°€ ë” ì í•©í•˜ë‹¤.
- ìŠ¤ë ˆë“œ ì•ˆì „í•œ ì„¤ê³„ê°€ í•„ìˆ˜ì´ë©°, ê³µìœ  ìì›ì—ëŠ” `mutex`, `semaphore` ë“±ì„ ì ìš©í•´ì•¼ í•œë‹¤.
- `pthread_join()` ëŒ€ì‹  `pthread_detach()`ë¥¼ ì‚¬ìš©í•˜ë©´ ë¶ˆí•„ìš”í•œ ëŒ€ê¸° ì—†ì´ ìë™ ì¢…ë£Œëœë‹¤.
- ì»¤ë„ì— ë”°ë¼ ìŠ¤ë ˆë“œëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ê²½ëŸ‰ í”„ë¡œì„¸ìŠ¤ë¡œ êµ¬í˜„ë˜ë©°, ì»¤ë„ ìŠ¤ì¼€ì¤„ë§ ë¹„ìš©ì´ ì¡´ì¬í•œë‹¤.

## 7.3 `thread pool` ê°œë… ë° êµ¬í˜„

### ğŸ“˜ ê°œìš”

`Thread Pool`ì€ ì„œë²„ ì„±ëŠ¥ê³¼ ì•ˆì •ì„±ì„ ê³ ë ¤í•˜ì—¬ **ë¯¸ë¦¬ ìƒì„±ëœ ì œí•œëœ ìˆ˜ì˜ ìŠ¤ë ˆë“œ ì§‘í•©**ì„ ì´ìš©í•´ í´ë¼ì´ì–¸íŠ¸ ìš”ì²­ì„ ì²˜ë¦¬í•˜ëŠ” êµ¬ì¡°ë‹¤.
 í•„ìš”í•  ë•Œë§ˆë‹¤ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ëŠ” `pthread` ë°©ì‹ì€ ì ‘ì† ìˆ˜ê°€ ì¦ê°€í• ìˆ˜ë¡ ì˜¤ë²„í—¤ë“œê°€ ì»¤ì§€ë¯€ë¡œ, ì´ë¥¼ ì œì–´í•˜ê¸° ìœ„í•œ íš¨ê³¼ì ì¸ ë°©ë²•ì´ `thread pool`ì´ë‹¤.

------

### ğŸ§± ì„¤ê³„ ê°œë… ìš”ì•½

- ì„œë²„ ì‹œì‘ ì‹œ ì¼ì • ìˆ˜ì˜ ìŠ¤ë ˆë“œë¥¼ ë¯¸ë¦¬ ìƒì„±
- í´ë¼ì´ì–¸íŠ¸ ìš”ì²­ì´ ë„ì°©í•˜ë©´ **ì‘ì—… í(task queue)**ì— ì‘ì—…ì„ ë“±ë¡
- ìœ íœ´ ìŠ¤ë ˆë“œ ì¤‘ í•˜ë‚˜ê°€ íì—ì„œ ì‘ì—…ì„ êº¼ë‚´ ì‹¤í–‰
- ìŠ¤ë ˆë“œëŠ” ì¢…ë£Œë˜ì§€ ì•Šê³  ëŒ€ê¸° ìƒíƒœë¡œ ëŒì•„ê°„ë‹¤

------

### ğŸ“ êµ¬ì„± ìš”ì†Œ

| êµ¬ì„± ìš”ì†Œ                       | ì„¤ëª…                                              |
| ------------------------------- | ------------------------------------------------- |
| **ì‘ì—… í (Task Queue)**        | ì²˜ë¦¬í•  í´ë¼ì´ì–¸íŠ¸ ì†Œì¼“ì„ ì €ì¥í•˜ëŠ” FIFO í         |
| **ì›Œì»¤ ìŠ¤ë ˆë“œ (Worker Thread)** | íì—ì„œ ì‘ì—…ì„ ê°€ì ¸ì™€ ì‹¤í–‰í•˜ê³  ë‹¤ì‹œ ëŒ€ê¸°           |
| **ë™ê¸°í™” ê°ì²´**                 | `mutex`, `condition variable` ë“±ìœ¼ë¡œ í ì ‘ê·¼ ë³´í˜¸ |
| **ìŠ¤ë ˆë“œ í’€ ê´€ë¦¬ì**            | ìŠ¤ë ˆë“œ ìƒì„±, ì¢…ë£Œ, ì—ëŸ¬ ê°ì‹œ ê¸°ëŠ¥ ë‹´ë‹¹            |

------

### ğŸ§ª ê°„ë‹¨í•œ êµ¬í˜„ ì˜ˆì œ

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <netinet/in.h>
#include <string.h>

#define PORT 8080
#define THREAD_COUNT 4
#define QUEUE_SIZE 10

int task_queue[QUEUE_SIZE];
int front = 0, rear = 0, count = 0;
pthread_mutex_t queue_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t queue_not_empty = PTHREAD_COND_INITIALIZER;

void enqueue(int client_sock) {
    pthread_mutex_lock(&queue_mutex);
    while (count == QUEUE_SIZE); // blocking when full (ê°„ë‹¨ êµ¬í˜„)
    task_queue[rear] = client_sock;
    rear = (rear + 1) % QUEUE_SIZE;
    count++;
    pthread_cond_signal(&queue_not_empty);
    pthread_mutex_unlock(&queue_mutex);
}

int dequeue() {
    pthread_mutex_lock(&queue_mutex);
    while (count == 0)
        pthread_cond_wait(&queue_not_empty, &queue_mutex);
    int client_sock = task_queue[front];
    front = (front + 1) % QUEUE_SIZE;
    count--;
    pthread_mutex_unlock(&queue_mutex);
    return client_sock;
}

void* worker_thread(void* arg) {
    while (1) {
        int client_sock = dequeue();
        char buffer[1024];
        int n;
        while ((n = read(client_sock, buffer, sizeof(buffer))) > 0) {
            write(client_sock, buffer, n); // echo
        }
        close(client_sock);
    }
}

int main() {
    int server_sock = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(PORT);
    addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_sock, (struct sockaddr*)&addr, sizeof(addr));
    listen(server_sock, 10);

    pthread_t threads[THREAD_COUNT];
    for (int i = 0; i < THREAD_COUNT; i++)
        pthread_create(&threads[i], NULL, worker_thread, NULL);

    while (1) {
        int client_sock = accept(server_sock, NULL, NULL);
        enqueue(client_sock); // ìš”ì²­ì„ íì— ë“±ë¡
    }

    close(server_sock);
    return 0;
}
```

------

### ğŸ” êµ¬ì¡°ì  íŠ¹ì§• ìš”ì•½

| í•­ëª©             | ì„¤ëª…                                         |
| ---------------- | -------------------------------------------- |
| ì²˜ë¦¬ ë°©ì‹        | ì œí•œëœ ìˆ˜ì˜ ìŠ¤ë ˆë“œê°€ ìˆœì°¨ì ìœ¼ë¡œ ìš”ì²­ ì²˜ë¦¬    |
| ë©”ëª¨ë¦¬ íš¨ìœ¨      | ë™ì  ìƒì„±ë³´ë‹¤ ì ìŒ                           |
| CPU íš¨ìœ¨         | context switching ìµœì†Œí™” ê°€ëŠ¥                |
| ì•ˆì •ì„±           | ê³¼ë„í•œ ìŠ¤ë ˆë“œ ìƒì„± ë°©ì§€                      |
| ë™ì‹œì„± ì œì–´ í•„ìš” | í ë³´í˜¸ë¥¼ ìœ„í•œ `mutex`, `cond` í•„ìˆ˜          |
| í•œê³„             | ì›Œì»¤ ìˆ˜ë³´ë‹¤ í´ë¼ì´ì–¸íŠ¸ ìˆ˜ê°€ ë§ìœ¼ë©´ ëŒ€ê¸° ë°œìƒ |

------

### ğŸ§  ì‹¤ë¬´ ê³ ë ¤ì‚¬í•­

- í í¬ê¸°ì™€ ì›Œì»¤ ìˆ˜ëŠ” ì„œë²„ ì„±ëŠ¥ê³¼ ì‚¬ìš© ì‹œë‚˜ë¦¬ì˜¤ì— ë”°ë¼ ì¡°ì •í•´ì•¼ í•œë‹¤.
- `epoll` + `thread pool` êµ¬ì¡°ë¥¼ ì¡°í•©í•˜ë©´ ê³ ì„±ëŠ¥ ëŒ€ê·œëª¨ ì„œë²„ êµ¬í˜„ì´ ê°€ëŠ¥í•˜ë‹¤.
- ëŒ€ê¸° ì¤‘ì¸ ì›Œì»¤ê°€ ì—†ì„ ë•Œ ì²˜ë¦¬ ì§€ì—°ì´ë‚˜ ê±°ì ˆ ë¡œì§(`backpressure`)ì„ ê³ ë ¤í•´ì•¼ í•œë‹¤.
- ìŠ¤ë ˆë“œ í’€ì˜ ìƒíƒœ(ì‘ì—… ìˆ˜, ëŒ€ê¸° ì¤‘ ìŠ¤ë ˆë“œ ìˆ˜ ë“±)ë¥¼ ëª¨ë‹ˆí„°ë§í•˜ëŠ” ë¡œì§ë„ ì¤‘ìš”í•˜ë‹¤.

## 7.4 race condition, mutex, semaphore ì‚¬ìš©ë²•

### ğŸ“˜ ê°œìš”

ë©€í‹°ìŠ¤ë ˆë“œ ë„¤íŠ¸ì›Œí¬ ì„œë²„ í™˜ê²½ì—ì„œ ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ê³µìœ  ìì›(ì˜ˆ: ì‘ì—… í, ì „ì—­ ë³€ìˆ˜, íŒŒì¼ ë“±)ì„ ë™ì‹œì— ì ‘ê·¼í•˜ë©´ ì˜ˆê¸°ì¹˜ ì•Šì€ ê²°ê³¼ë¥¼ ì´ˆë˜í•  ìˆ˜ ìˆë‹¤. ì´ë¥¼ **Race Condition(ê²½ìŸ ìƒíƒœ)**ì´ë¼ê³  í•˜ë©°, ì ì ˆí•œ ë™ê¸°í™” ê¸°ë²•ì´ í•„ìš”í•˜ë‹¤.

ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•œ ëŒ€í‘œì ì¸ ë™ê¸°í™” ë„êµ¬ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤:

- **Mutex (Mutual Exclusion)**: ìƒí˜¸ ë°°ì œë¥¼ í†µí•´ í•œ ë²ˆì— í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œë§Œ ìì›ì— ì ‘ê·¼ ê°€ëŠ¥í•˜ë„ë¡ ë³´ì¥
- **Semaphore**: ê°œìˆ˜ ê¸°ë°˜ì˜ ì ‘ê·¼ ì œì–´ë¡œ, íŠ¹ì • ìì›ì— ëŒ€í•´ ë™ì‹œ ì ‘ê·¼ ê°€ëŠ¥í•œ ìŠ¤ë ˆë“œ ìˆ˜ë¥¼ ì œí•œ

------

### ğŸ§¨ Race Conditionì˜ ì˜ˆì‹œ

```
int counter = 0;

void* thread_func(void* arg) {
    for (int i = 0; i < 100000; i++)
        counter++; // ë™ì‹œ ì ‘ê·¼ìœ¼ë¡œ ì¸í•´ ê²°ê³¼ ë¶ˆì¼ì¹˜ ê°€ëŠ¥ì„±
    return NULL;
}
```

- ìœ„ ì½”ë“œëŠ” ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ `counter++`ë¥¼ ë™ì‹œì— ì‹¤í–‰í•˜ë©´ì„œ ì¤‘ë³µëœ ì½ê¸°/ì“°ê¸° ë°œìƒ
- ê²°ê³¼ì ìœ¼ë¡œ ê¸°ëŒ€ê°’ë³´ë‹¤ ì ì€ ê°’ì´ ì¶œë ¥ë  ìˆ˜ ìˆìŒ

------

### ğŸ” Mutex ì‚¬ìš©ë²•

```
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

void* thread_func(void* arg) {
    for (int i = 0; i < 100000; i++) {
        pthread_mutex_lock(&lock);
        counter++;
        pthread_mutex_unlock(&lock);
    }
    return NULL;
}
```

- **`pthread_mutex_lock()`**: ë½ íšë“ (ë‹¤ë¥¸ ìŠ¤ë ˆë“œëŠ” ëŒ€ê¸°)
- **`pthread_mutex_unlock()`**: ë½ í•´ì œ
- **ì£¼ì˜**: ë½ì„ ê±¸ê³  ë‚˜ì„œ `return` ë˜ëŠ” `exit`ë˜ë©´ ë°ë“œë½ ìœ„í—˜ ì¡´ì¬

------

### ğŸ”„ Semaphore ì‚¬ìš©ë²•

```
#include <semaphore.h>

sem_t sem;

void* thread_func(void* arg) {
    for (int i = 0; i < 100000; i++) {
        sem_wait(&sem);   // ì„¸ë§ˆí¬ì–´ íšë“
        counter++;
        sem_post(&sem);   // ì„¸ë§ˆí¬ì–´ í•´ì œ
    }
    return NULL;
}

int main() {
    sem_init(&sem, 0, 1); // ì„¸ë§ˆí¬ì–´ ì´ˆê¸°ê°’ 1 (binary semaphore)
    // ...
}
```

- **`sem_wait()`**: ì„¸ë§ˆí¬ì–´ ê°’ì´ 0ì´ë©´ ëŒ€ê¸°, 1 ì´ìƒì´ë©´ ê°’ì„ 1 ê°ì†Œì‹œí‚¤ê³  ì§„ì…
- **`sem_post()`**: ì„¸ë§ˆí¬ì–´ ê°’ì„ 1 ì¦ê°€ (ëŒ€ê¸° ìŠ¤ë ˆë“œ ì¤‘ í•˜ë‚˜ë¥¼ ê¹¨ì›€)
- **Binary Semaphore (ê°’ 0 ë˜ëŠ” 1)**ì€ Mutexì™€ ìœ ì‚¬í•œ ì—­í• 

------

### ğŸ“Š ë¹„êµ ìš”ì•½í‘œ

| í•­ëª©        | Mutex                       | Semaphore                        |
| ----------- | --------------------------- | -------------------------------- |
| ê¸°ë³¸ ëª©ì    | ìƒí˜¸ ë°°ì œ                   | ë™ì‹œ ì ‘ê·¼ ì œí•œ                   |
| ì´ˆê¸°ê°’      | ì—†ìŒ (ë¬´ì¡°ê±´ 1 ìŠ¤ë ˆë“œ)      | ì •ìˆ˜ (Nê°œì˜ ë™ì‹œ ì ‘ê·¼ í—ˆìš©)      |
| ì‚¬ìš© í•¨ìˆ˜   | `pthread_mutex_lock/unlock` | `sem_wait/post`                  |
| ë°ë“œë½ ìœ„í—˜ | ìˆìŒ                        | ìˆìŒ (ê´€ë¦¬ ë¯¸ìˆ™ì‹œ)               |
| ì£¼ ìš©ë„     | ì„ê³„ ì˜ì—­ ë³´í˜¸              | ì œí•œëœ ìì› ì ‘ê·¼ (ì˜ˆ: DB ì»¤ë„¥ì…˜) |

------

### ğŸ§  ì‹¤ë¬´ ì ìš© íŒ

- `mutex`ëŠ” **ë‹¨ì¼ ìì› ë³´í˜¸**ì— ì í•©í•˜ë©°, ê°„ê²°í•˜ê³  ë¹ ë¥´ë‹¤.
- `semaphore`ëŠ” **Nê°œ ìì› ì œí•œ** í˜¹ì€ **ìƒì‚°ì/ì†Œë¹„ì íŒ¨í„´** êµ¬í˜„ì— ì í•©í•˜ë‹¤.
- `pthread_mutex_trylock()`ìœ¼ë¡œ **ë…¼ë¸”ë¡œí‚¹ ë½ ì‹œë„** ê°€ëŠ¥.
- `pthread_rwlock_t`ë¥¼ ì‚¬ìš©í•˜ë©´ **ì½ê¸°-ì“°ê¸° ë¶„ë¦¬ ë™ê¸°í™”** êµ¬í˜„ ê°€ëŠ¥.
- ë‹¤ì¤‘ ìì› ë½ ìˆœì„œê°€ ê¼¬ì´ë©´ ë°ë“œë½ì´ ë°œìƒí•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ, **ë½ íšë“ ìˆœì„œ ê³ ì •** í•„ìš”.

## 7.5 í”„ë¡œì„¸ìŠ¤/ìŠ¤ë ˆë“œ ê°„ í†µì‹  (pipe, socketpair, message queue ë“±)

### ğŸ“˜ ê°œìš”

ë©€í‹°í”„ë¡œì„¸ìŠ¤ ë˜ëŠ” ë©€í‹°ìŠ¤ë ˆë“œ í”„ë¡œê·¸ë¨ì—ì„œ **ë°ì´í„° ê³µìœ ì™€ ë™ê¸°í™”**ë¥¼ ìœ„í•´ í†µì‹ ì´ í•„ìš”í•˜ë‹¤. íŠ¹íˆ ë„¤íŠ¸ì›Œí¬ ì„œë²„ì—ì„œëŠ” ë¡œê·¸ ì²˜ë¦¬, ë°±ì—”ë“œ ì‘ì—… ë¶„ì‚°, í”„ë¡œì„¸ìŠ¤ ê°„ ì´ë²¤íŠ¸ ì „ë‹¬ ë“± ë‹¤ì–‘í•œ ëª©ì ì„ ìœ„í•´ **IPC(Inter-Process Communication)** ê¸°ë²•ì´ ì‚¬ìš©ëœë‹¤.

------

### ğŸ“š ëŒ€í‘œ IPC ë°©ì‹

| ë°©ì‹                | ëŒ€ìƒ                 | íŠ¹ì§•                        | ì–‘ë°©í–¥ | ë¹„ê³                          |
| ------------------- | -------------------- | --------------------------- | ------ | ---------------------------- |
| **pipe**            | í”„ë¡œì„¸ìŠ¤ ê°„          | ë‹¨ë°©í–¥, ë¶€ëª¨-ìì‹ ê°„ ì‚¬ìš©   | âŒ      | `fork()` í›„ ê³µìœ ë¨           |
| **socketpair**      | í”„ë¡œì„¸ìŠ¤/ìŠ¤ë ˆë“œ ëª¨ë‘ | ì–‘ë°©í–¥, ë¡œì»¬ ì†Œì¼“ ì‚¬ìš©      | âœ…      | UNIX ë„ë©”ì¸ ì†Œì¼“ ê¸°ë°˜        |
| **message queue**   | í”„ë¡œì„¸ìŠ¤ ê°„          | ì»¤ë„ ê¸°ë°˜ ë©”ì‹œì§€ í         | âŒ      | í‚¤ë¡œ ì‹ë³„, ì‹œìŠ¤í…œ V API ì‚¬ìš© |
| **shared memory**   | í”„ë¡œì„¸ìŠ¤ ê°„          | ë¹ ë¥¸ ë°ì´í„° êµí™˜ ê°€ëŠ¥       | ì–‘ë°©í–¥ | ë³„ë„ ë™ê¸°í™” í•„ìš”             |
| **mutex/condition** | ìŠ¤ë ˆë“œ ê°„            | ë™ê¸°í™” ëª©ì  (ë°ì´í„° ì „ë‹¬ X) | âŒ      | `pthread` ê¸°ë°˜ ìŠ¤ë ˆë“œ ì œí•œ   |

------

### 1ï¸âƒ£ pipe: ë‹¨ë°©í–¥ í†µì‹  (ìµëª… íŒŒì´í”„)

#### ì˜ˆì‹œ ì½”ë“œ (ë¶€ëª¨-ìì‹ ê°„ ë¬¸ìì—´ ì „ë‹¬)

```
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main() {
    int fd[2]; // fd[0]: read, fd[1]: write
    pipe(fd);

    if (fork() == 0) {
        // ìì‹ í”„ë¡œì„¸ìŠ¤
        close(fd[1]); // ì“°ê¸° ë‹«ê¸°
        char buf[100];
        read(fd[0], buf, sizeof(buf));
        printf("ìì‹ ìˆ˜ì‹ : %s\n", buf);
    } else {
        // ë¶€ëª¨ í”„ë¡œì„¸ìŠ¤
        close(fd[0]); // ì½ê¸° ë‹«ê¸°
        char msg[] = "Hello from parent";
        write(fd[1], msg, strlen(msg) + 1);
    }
}
```

------

### 2ï¸âƒ£ socketpair: ì–‘ë°©í–¥ í†µì‹  (ë¡œì»¬ ì „ìš©)

#### ì˜ˆì‹œ ì½”ë“œ

```
#include <sys/socket.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>

int main() {
    int sv[2];
    socketpair(AF_UNIX, SOCK_STREAM, 0, sv);

    if (fork() == 0) {
        close(sv[0]);
        char buf[100];
        read(sv[1], buf, sizeof(buf));
        printf("ìì‹ ìˆ˜ì‹ : %s\n", buf);
        write(sv[1], "pong", 5);
    } else {
        close(sv[1]);
        write(sv[0], "ping", 5);
        char reply[100];
        read(sv[0], reply, sizeof(reply));
        printf("ë¶€ëª¨ ìˆ˜ì‹ : %s\n", reply);
    }
}
```

- `AF_UNIX`ì€ ë¡œì»¬ ì‹œìŠ¤í…œ ë‚´ í†µì‹ ìš© ì†Œì¼“ ë„ë©”ì¸
- TCP ì†Œì¼“ ì—†ì´ë„ ì•ˆì •ì ì¸ IPC ê°€ëŠ¥

------

### 3ï¸âƒ£ System V ë©”ì‹œì§€ í

#### íŠ¹ì§•

- `msgget`, `msgsnd`, `msgrcv` API ì‚¬ìš©
- ë©”ì‹œì§€ë¥¼ êµ¬ì¡°ì²´ í˜•íƒœë¡œ ì†¡ìˆ˜ì‹ 
- í‚¤ ê¸°ë°˜ ì‹ë³„ì ì‚¬ìš©

#### êµ¬ì¡°ì²´ ì •ì˜

```
struct msgbuf {
    long mtype;
    char mtext[100];
};
```

#### ì‚¬ìš© ì˜ˆ

```
#include <sys/ipc.h>
#include <sys/msg.h>

struct msgbuf msg = {1, "Hello"};

int msgid = msgget(1234, IPC_CREAT | 0666);
msgsnd(msgid, &msg, sizeof(msg.mtext), 0);
msgrcv(msgid, &msg, sizeof(msg.mtext), 1, 0);
```

------

### 4ï¸âƒ£ ìŠ¤ë ˆë“œ ê°„ í†µì‹ : ê³µìœ  ë³€ìˆ˜ + ë™ê¸°í™”

ë©€í‹°ìŠ¤ë ˆë“œì—ì„œëŠ” ê³µí†µ ë³€ìˆ˜ì— ë°ì´í„°ë¥¼ ì €ì¥í•˜ê³  `mutex`, `condition`ìœ¼ë¡œ ì ‘ê·¼ì„ ì¡°ìœ¨í•¨.

```
int shared_data;
pthread_mutex_t lock;

void* producer(void*) {
    pthread_mutex_lock(&lock);
    shared_data = 100;
    pthread_mutex_unlock(&lock);
}
```

> ì§ì ‘ì ì¸ ë©”ì‹œì§€ ì „ì†¡ì€ ì—†ì§€ë§Œ ê³µìœ  ë©”ëª¨ë¦¬ë¥¼ í†µí•´ í†µì‹ ì´ ê°€ëŠ¥í•˜ë‹¤.
>  Race condition ë°©ì§€ë¥¼ ìœ„í•´ ë½ í•„ìˆ˜.

------

### ğŸ“Œ IPC ë°©ì‹ ì„ íƒ ê¸°ì¤€ ìš”ì•½

| ìƒí™©                            | ì¶”ì²œ ë°©ì‹           |
| ------------------------------- | ------------------- |
| ë¶€ëª¨-ìì‹ ê°„ ê°„ë‹¨í•œ ë©”ì‹œì§€ ì „ë‹¬ | `pipe`              |
| ì–‘ë°©í–¥ í†µì‹  í•„ìš”, fork ì‚¬ìš©     | `socketpair`        |
| ë³„ë„ í”„ë¡œì„¸ìŠ¤ ê°„ í í˜•íƒœ ì „ë‹¬   | `message queue`     |
| ë‹¤ëŸ‰ì˜ ë°ì´í„°, ê³ ì† ì²˜ë¦¬        | `shared memory`     |
| ë™ì¼ í”„ë¡œì„¸ìŠ¤ ë‚´ ìŠ¤ë ˆë“œ         | ê³µìœ  ë³€ìˆ˜ + `mutex` |